{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Getting Started","text":"<p>Hello. This is a detailed documentation about the new server authority system that Roblox has showcased recently. It is a new system aiming to achieve a better physics simulation, while also providing better security. This documentation will try to give you almost all of the available information about this new system. However, not all information may be accurate, as this system is still a work-in-progress.</p> <p>With all that being said, this documentation may recieve updates whenever there's a new feature added, or a feature removed. If you want to stay up-to-date, make sure to visit this documentation again later, and if you have any additional information that you can provide about this system, let me know with a message on my Twitter.</p> <p>Let's begin.</p>"},{"location":"#how-to-access","title":"How to Access?","text":"<p>The simplest way you can gain access to the new features, is through enrolling to the Early Access Program for the Server Authority Core API. You can send a reply to this thread to apply for the program. </p> <p>If you're accepted, go to your account settings, and scroll down to the \"Early Access Programs\" section. Then, select the \"Early Access: Server Authority Core API Early Access\" program. This will now enroll you to the program, and by following the steps below, you can access the features.</p>"},{"location":"#if-using-vanilla-studio","title":"If using vanilla Studio","text":"<p>Restart your Studio. Upon the restart, there will be an \"Update Studio\" button on the top right. Clicking this button will automatically update your Studio and install the version meant for the program. After this, you should be good to go.</p>"},{"location":"#if-using-a-custom-bootstrapper","title":"If using a custom bootstrapper","text":"<p>If your custom bootstrapper application to launch Studio does not have a built-in system for automatically opening the version meant for the early access program, then follow the steps below.</p> <p>Go to your creator page. And re-download the Studio application. After install, it should automatically open. Click on the \"Update Studio\" button on the top right. This will automatically update your Studio and install the version meant for the program. After this, you should be good to go.</p> <p>Do not forget to launch the Studio application through the versions folder for the installed Studio application. Using your custom bootstrapper may not work.</p> <p>You must also repeat these steps if you wish to roll-out of the program.</p>"},{"location":"#what-is-server-authority","title":"What is Server Authority?","text":"<p>Server Authority is when the server becomes the only source of truth for game actions, logic and data in your world.</p> <p>In this model, clients can no longer hold network ownership of any instances. This ensures the trusted data replicated from the client to the server is kept at a minimum. The only trusted data that the server recieves from the clients are their inputs, which is used to simulate their characters or systems controlled by them. This results in a far more secure model, which reduces or outright removes many problems that have arisen from giving clients network ownership of certain parts and systems in your world. </p>"},{"location":"#how-does-this-effect-the-physics-around-my-world","title":"How does this effect the physics around my world?","text":"<p>Server Authority completely changes the behavior of all unanchored <code>Part</code>s in the <code>Workspace</code>. Before; the physics calculation of a <code>Part</code> was handled by both the server and the clients in a place. When a client came close to a <code>Part</code>, the network ownership would automatically shift from the server to the client, so the client could take the burden of calculating the physics for that <code>Part</code>.</p> <p>A similar case was also in effect for the characters too. Before, because of network ownership, the client had full control over their character. This allowed them to change certain properties of their character such as velocity, position, rotation, and many others to their liking. This of course, caused many security issues. Using exploits, the client would be able to give themselves an unfair advantage in gameplay by changing these properties. This gave the rise of many exploiting issues such as speed-hacking, fly-hacking, no-clipping, teleporting, and many others inside popular places on the platform.</p> <p>The issues are not only limited to exploiting. In many competitive games, such as racing, the cars would most of the time be misaligned, or their position would constantly jitter, or look very different. That is because of client calculated physics of the previous system. Because the network ownership of each car is set to each client, rather than the server, the car positions would end up different than expected.</p> <p>However, with Server Authority, most of these issues, if not all of them, are automatically resolved.</p> <p>For the case of the character, where a client would modify their character to gain an unfair advantage such as speedhacking, would no longer be possible, as the client no longer holds ownership of their character, and all that is given to the server are inputs.</p> <p>For the case of the racing games, since the server now calculates the positions of the cars, they now move more consistently. Maneuvers, drifts, hits become more accurate, and the system works as smooth as possible.</p>"},{"location":"#the-problem-with-server-authority","title":"The Problem with Server Authority","text":"<p>For the reasons I've given above, Server Authority sounds amazing, it improves accuracy, increases security and overall produces a better experience for players, right? Not exactly.</p> <p>Server Authority on its own is horrible for player experience. This is simply due to the fact that players are from all around the world, where they might be hundereds, if not thousands of miles away from the nearest server. This distance means their ping will be high, which means the time it will take for a player's input to reach the server will also be high. This creates a choppy, very uncomfortable experience where a player might only start seeing their character move after a long time has passed since they sent their input. Imagine pressing the \"W\" key and only seeing your character move after a second or two. It would make it incredibly hard to play a game, if not outright impossible for some players.</p> <p>Luckily, there is a solution that exists which solves these problems. This solution has existed for a very long time, and many competitive games out there already use it. It is called \"Rollback Netcode\".</p>"},{"location":"#what-is-rollback-netcode","title":"What is Rollback Netcode?","text":"<p>Unfortunately, I cannot give you an in-depth explanation on what Rollback Netcode is, as it is a relatively complex concept, and I do not wish to fill this documentation with every detail of it. By doing a small bit of research, you can find some really good articles on it, such as this one, on the web to learn more. I will give you a short summary on what the concept is however, so rest assured.</p> <p>This concept is when the client also simulates its own input alongside the server, but just a little bit ahead of it. For the inputs to feel responsive and smooth, the client immediately simulates them when they are given, while sending them to the server. Since the server is the authority here, this simulation doesn't hold an important value, and is purely done for the visuals, so we call them \"prediction\"s. Essentially, the client \"predicts\" how their inputs will effect the game state (e.g, their character), while the server determines how their inputs will actually effect the game state.</p> <p>However, there might be times where the client prediction and the actual simulation results may differ from each other. For example, assuming T is the current time, the client has made a prediction at T-3, and when the authoritative update arrives for T-3 from the server, the client notices its prediction and the authoritative update results are different from each other. This is called a \"Misprediction\". In this case, the client rolls back to the authoritative update frame by reverting its current state and time. Then, the client resimulates automatically after rollback to speed back to its current predicted frame. The number of frames to resimulate is based on the latency between the client and the server. The client tries to stay far enough ahead of the server so that its own inputs arrive on the server just in time to be processed on the frame the player intended to perform them.</p> <p>Mispredictions are normal and expected. They should be small and the resulting correction should be imperceptible to clients.</p> <p></p> <p>Example</p> <p>Your client thinks you\u2019ve moved forward. However, the server registered that you were hit by a stun grenade and can\u2019t move for a few  seconds. The client and server now have different states.</p> <p>Like I have mentioned above, this divergence is called a misprediction. It can occur for several reasons: the network latency has shifted, other players acted in ways the client didn\u2019t anticipate, the experience runs certain logic exclusively on the server, etc. While you can't prevent every misprediction, you can keep gameplay feeling smooth and responsive by using the right techniques.</p> <p>Example</p> <p>Let\u2019s say there is 100ms of latency between the client and server, and the experience is a 60Hz game.</p> <p>Each frame is 1/60s (or 16.67ms). Since 100ms of latency is equivalent to ~6 frames (100 ms divided by 16.67 ms/frame), we know the client will be 6 frames ahead of the server. This means that, when the client detects it made a misprediction, it will rollback to the server's state and then resimulate frames ahead. In general, the player should hardly notice this.</p>"},{"location":"#the-input-action-system","title":"The Input Action System","text":"<p>The Input Action System (IAS) is a major part of the server authority system. It allows you to reliably transfer inputs from client to the server, while allowing you to customize them easily. I will not be explaining this system and how it works however. You can check out the main post talking about it through here.</p> <p>Player inputs like joystick movement and button presses are sent from client to server using <code>InputAction</code>s. You have to use <code>InputAction</code> for all inputs that affect the core game simulation, because they are the only client authoritative data in the core rollback system.</p> <p>You can send any continuous stream of data from the client to server using this API, and the server will trust what the client has sent. It is up to you to validate that the clients have sent legitimate inputs. Be sure to enforce maximum and minimum ranges on numbers sent from the client, just like how you would validate values sent from remotes.</p> <p>Note</p> <p>The server will automatically ignore input data from the client if it arrives far too late or far too early, which can happen if there are sudden changes in a client's network conditions.</p>"},{"location":"examples/","title":"Examples","text":"<p>Welcome to the Examples section! In this section, you can find examples of systems you can implement with Server Authority. On the left side, there are pages which contain tutorials and snippets of code which may help you to learn how to do various small or large scale systems with Server Authority.</p> <p>Note</p> <ul> <li>Each example contains two ways to achieve the same system. </li> </ul>"},{"location":"examples/#open-source-projects-from-roblox","title":"Open-Source Projects from Roblox","text":"<p>Besides example pages, there are certain open-source projects created by Roblox with Server Authority. You can also check them out!</p>"},{"location":"examples/#the-soccer-game","title":"The Soccer Game","text":"<p>In this game, you play soccer while rolling around in a ball, playing against the opposite team.</p> <p>Play and edit the game on Roblox here.</p>"},{"location":"examples/character/","title":"Character Movement System","text":"<p>This is an example character movement system that you can create with Server Authority.</p> <p>Deprecated</p> <p>In the newer versions, Server Authority comes with an updated <code>PlayerModule</code> that does and supports everything mentioned in this tutorial. This tutorial will continue to exist as an example, however.</p>"},{"location":"examples/character/#the-design","title":"The Design","text":"<p>We will create a simple character movement system, that will allow the player to move in any direction. To do this, we can use a multi-script architecture (the Modular Way), or a singular script architecture (the Behavior Way) to run our simulation code on both the Server and the Client. It is recommended that you use the modular way, as the behavior way is unstable and not finished yet.</p>"},{"location":"examples/character/#default-modular-way","title":"Default (Modular) Way","text":"<p>First, under the \"ServerAuthority\" folder in <code>ReplicatedStorage</code>, we create a <code>ModuleScript</code> named \"CharacterMovement\". This will be our main module which will contain the movement system. It will be used both by the server and the client.</p> <p>The hierarchy should look like this:</p> <p></p> <p>Then, in this module, we bind our movement function to the simulation using the <code>RunService:BindToSimulation(callback: (deltaTime: number) -&gt; ())</code> method with a callback function.</p>"},{"location":"examples/character/#charactermovement","title":"CharacterMovement","text":"<pre><code>local RunService = game:GetService(\"RunService\")\n\nlocal MovementModule = {\n    Connections = {} :: {RBXScriptConnection}\n}\n\n -- This function begins the movement calculation for a player.\nfunction MovementModule.BeginMovement(player: Player)\n    -- We bind our function to the simulation using RunService, and add the Connection object to the Connections table to track it.\n    MovementModule.Connections[player] = RunService:BindToSimulation(function(deltaTime: number)\n        -- This will be the function to start calculating the movement of a player's character in.\n    end)\nend\n\n-- This function stops the movement calculation for a player.\nfunction MovementModule.EndMovement(player: Player) \n    local FoundConnection: RBXScriptConnection? = MovementModule.Connections[player]\n    if not FoundConnection then return end\n\n    FoundConnection:Disconnect()\n    MovementModule.Connections[player] = nil\nend\n\nreturn MovementModule\n</code></pre> <p>We now have a simple initial system that allows us to connect to the <code>.FixedHeartbeat</code> signal. Before we continue to write the actual calculation system however, we need to create some new <code>Instance</code>s to get the input from the player.</p> <p>To do this, we create another folder called \"Input\" and create an <code>InputContext</code> with certain <code>InputAction</code>s parented to it, allowing us to get movement input from the player's client.</p> <p>We will create 4 <code>InputAction</code>s under this <code>InputContext</code>, called: \"Camera\", \"Jump\", \"Move\", \"Rotation\". To support both gamepad and keyboard input, we create two <code>InputBinding</code>s under the \"Jump\" and \"Move\" <code>InputAction</code>s.</p> <p>For the \"Jump\" <code>InputAction</code> (<code>Bool</code> Type), we will add the <code>Space</code> KeyCode to first <code>InputBinding</code>, called \"KeyboardBinding\". And for the next one, which we can call \"GamepadBinding\", we add the <code>ButtonA</code> KeyCode.</p> <p>For the \"Move\" <code>InputAction</code> (<code>Direction2D</code> Type), we will add 4 directions to the first <code>InputBinding</code> meant for keyboard, called \"KeyboardBinding\":</p> <ul> <li>Down: <code>S</code></li> <li>Up: <code>W</code></li> <li>Left: <code>A</code></li> <li>Right: <code>D</code></li> </ul> <p>For the next <code>InputBinding</code>, called \"GamepadBinding\", we will set the KeyCode to <code>Thumbstick 1</code>.</p> <p>The hierarchy should now look like this:</p> <p></p> <p>We will be cloning this input system to the player object with a script later.</p> <p>We can now move on to creating the actual system which will calculate the movement for the character.</p>"},{"location":"examples/character/#charactermovement_1","title":"CharacterMovement","text":"<pre><code>local RunService = game:GetService(\"RunService\")\n\nlocal MovementModule = {\n    Connections = {} :: {RBXScriptConnection}\n}\n\n -- This is the function that begins the movement calculation for a player.\nfunction MovementModule.BeginMovement(player: Player)\n    -- We bind our function to the simulation using RunService, and add the Connection object to the Connections table to track it.\n    MovementModule.Connections[player] = RunService:BindToSimulation(function(deltaTime: number)\n        if not player.Character then return end -- If the character has not loaded yet, return.\n\n        local Character = player.Character\n        local Humanoid: Humanoid = Character.Humanoid \n        local Input: InputContext = player.Input.Default\n\n        local MoveInput: InputAction = Input.Move\n        local CameraInput: InputAction = Input.Camera\n        local RotationInput: InputAction = Input.Rotation\n        local JumpInput: InputAction = Input.Jump\n\n        -- Getting the values from InputActions. We use :GetState() here instead of .StateChanged.\n        local MoveVector2D: Vector2 = MoveInput:GetState() \n        local CameraVector2D: Vector2 = CameraInput:GetState()\n        local RotationIsCameraRelative: boolean = RotationInput:GetState()\n        local JumpBoolean: boolean = JumpInput:GetState()\n\n        -- Calculating the move direction based on camera and movement input.\n        local CameraVector3D = Vector3.new(CameraVector2D.X, 0, CameraVector2D.Y)\n        local RightVector = CameraVector3D:Cross(Vector3.yAxis)\n\n        local MoveVector = CameraVector3D * MoveVector2D.Y + RightVector * MoveVector2D.X\n        local MoveDirection = Vector3.new(MoveVector.X, 0, MoveVector.Z)\n\n        -- Moving the Humanoid to the target move direction.\n        Humanoid:Move(MoveDirection)\n\n        -- Rotating the Character based on camera direction.\n        if RotationIsCameraRelative then\n            Humanoid.AutoRotate = false\n            if not Humanoid.SeatPart and Humanoid.RootPart then\n                Humanoid.RootPart.CFrame = CFrame.new(Humanoid.RootPart.CFrame.Position, Humanoid.RootPart.CFrame.Position + CameraVector3D)\n            end\n        else\n            Humanoid.AutoRotate = true\n        end\n\n        -- Allowing the Character to jump based on input, and if it's not currently in-air.\n        local currentState = Humanoid:GetState()\n        local isInAir = currentState == Enum.HumanoidStateType.FallingDown\n            or currentState == Enum.HumanoidStateType.Freefall\n            or currentState == Enum.HumanoidStateType.Jumping\n\n        if not isInAir and JumpBoolean then\n            Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)\n        end\n    end)\nend\n\n-- This function stops the movement calculation for a player.\nfunction MovementModule.EndMovement(player: Player) \n    local FoundConnection: RBXScriptConnection? = MovementModule.Connections[player]\n    if not FoundConnection then return end\n\n    FoundConnection:Disconnect()\n    MovementModule.Connections[player] = nil\nend\n\nreturn MovementModule\n</code></pre> <p>Our system is almost ready! Now, for the system to start working, we need to initialize and run this module from both the server and the client. And we also need to clone and parent the \"Input\" folder we created above to the player, so the system can start capturing input from the client.</p>"},{"location":"examples/character/#serversetup","title":"ServerSetup","text":"<pre><code>local Players = game:GetService(\"Players\")\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal ServerAuthority = ReplicatedStorage.ServerAuthority\nlocal Modules = ServerAuthority.Modules\nlocal Input = ServerAuthority.Input\n\nlocal CharacterMovement = require(Modules.CharacterMovement)\n\n-- This function sets the streaming mode for the character model to Atomic upon character load.\nlocal function InitializeCharacter(character: Model)\n    character.ModelStreamingMode = Enum.ModelStreamingMode.Atomic\nend\n\n-- This function clones and parents the Input folder to the player to start capturing input, and begins the movement calculation.\nlocal function InitializePlayer(player: Player)\n    if player.Character then InitializeCharacter(player.Character) end\n    player.CharacterAdded:Connect(InitializeCharacter)\n\n    local InputTemplate = Input:Clone()\n    InputTemplate.Parent = player\n\n    CharacterMovement.BeginMovement(player)\nend\n\n-- This function initializes the above functions for all existing players, or new players.\nlocal function Initialize()\n    for _, player in Players:GetPlayers() do\n        InitializePlayer(player)\n    end\n    Players.PlayerAdded:Connect(InitializePlayer)\nend\n\n-- We want to only run the above systems when the AuthorityMode is set to Server. Automatic results in inconsistent behavior.\nif workspace.AuthorityMode == Enum.AuthorityMode.Server then\n    Initialize()\nend\n</code></pre> <p>This is our server script that initializes the movement calculation and input parenting for a player. This is our main system that allows the player to move.</p>"},{"location":"examples/character/#clientsetup","title":"ClientSetup","text":"<pre><code>local Players = game:GetService(\"Players\")\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal ServerAuthority = ReplicatedStorage.ServerAuthority\nlocal Modules = ServerAuthority.Modules\n\nlocal CharacterMovement = require(Modules.CharacterMovement)\nlocal LocalPlayer = Players.LocalPlayer\n\n-- This function begins the client prediction for the character.\nlocal function InitializeCharacter(character: Model)\n    local HumanoidRootPart: Part = character:WaitForChild(\"HumanoidRootPart\")\n    HumanoidRootPart:SetPredictionMode(Enum.PredictionMode.On)\nend\n\n-- This function initializes the movement prediction and the character.\nlocal function Initialize()\n    if LocalPlayer.Character then InitializeCharacter(LocalPlayer.Character) end\n    LocalPlayer.CharacterAdded:Connect(InitializeCharacter)\n\n    CharacterMovement.BeginMovement(LocalPlayer)\nend\n\n-- We want to only run the above systems when the AuthorityMode is set to Server. Automatic results in inconsistent behavior.\nif workspace.AuthorityMode == Enum.AuthorityMode.Server then\n    Initialize()\nend\n</code></pre> <p>This is our client script that initializes the movement prediction for a player. This is our main system that allows a smooth experience for the player movement.</p> <p>However, we also need to create another client script to capture input for the camera:</p>"},{"location":"examples/character/#camerainput","title":"CameraInput","text":"<pre><code>local Players = game:GetService(\"Players\")\nlocal RunService = game:GetService(\"RunService\")\nlocal UserGameSetting = UserSettings():GetService(\"UserGameSettings\")\n\nlocal LocalPlayer = Players.LocalPlayer\n\n-- Defining the InputActions for the camera and rotation.\nlocal Input = LocalPlayer:WaitForChild(\"Input\")\nlocal CameraInput: InputAction = Input.Default.Camera\nlocal RotationInput: InputAction = Input.Default.Rotation\n\nif workspace.AuthorityMode == Enum.AuthorityMode.Server then\n    -- This callback function calculates the current rotation of the character and the camera, and sends it to the server.\n    RunService:BindToRenderStep(\"CameraInput\", Enum.RenderPriority.Last.Value, function()\n        local Camera = workspace.CurrentCamera\n        local YAxis: Vector3 = Vector3.yAxis\n        local Forward = YAxis:Cross(Camera.CFrame.RightVector)\n\n        CameraInput:Fire(Vector2.new(Forward.X, Forward.Z))\n        RotationInput:Fire(UserGameSetting.RotationType == Enum.RotationType.CameraRelative)\n    end)\nend\n</code></pre> <p>After everything above has been complete, our new system hierarchy should now look like this:</p> <p></p> <p>And that's all! Hitting the \"Play\" button should allow you to test our new system. This new character system provides a secure and accurate character simulation, while behaving smoothly for the player's view.</p>"},{"location":"examples/character/#behavior-way","title":"Behavior Way","text":"<p>While the modular system works, it is not fully desirable as it requires us to create loaders from both the server and the client, and a module script which runs the movement system. To make make it more desirable and easier for us to create Server Authority systems, there exists a new <code>Instance</code> called <code>AuroraScript</code>. This new instance allows us to define a behavior which will both run on the server and the client.</p> <p>To learn more about Behaviors, check out the Behaviors section.</p> <p>First we create a new <code>AuroraScript</code> called \"CharacterMovement\". This will be our main script which will contain the movement system.</p>"},{"location":"examples/character/#charactermovement_2","title":"CharacterMovement","text":"<pre><code>local RunService = game:GetService(\"RunService\")\nlocal Players = game:GetService(\"Players\")\n\ntype AuroraScriptObject = {\n    Instance: Instance,\n    Frame: number,\n    LODLevel: number,\n    Connect: (self: AuroraScriptObject, signal: RBXScriptSignal, functionName: string) -&gt; RBXScriptConnection,\n    Subscribe: (self: AuroraScriptObject, topic: string, functionName: string) -&gt; string,\n    Publish: (self: AuroraScriptObject, topic: string, ...any) -&gt; any,\n    SendMessage: (self: AuroraScriptObject, boundInstance: Instance, behaviorName: string, functionName: string, ...any) -&gt; ...any,\n    Delay: (self: AuroraScriptObject, amount: number, functionName: string) -&gt; string,\n    SetMaxFrequency: (self: AuroraScriptObject, frequency: number) -&gt; number,\n    [string]: any\n}\n\n-- This function runs when the Behavior starts.\nfunction Behavior.OnStart(self: AuroraScriptObject)\n    -- We bind the DefaultMovement method of the Behavior to the Simulation.\n    RunService:BindToSimulation(function(deltaTime: number) \n        self:DefaultMovement(deltaTime)\n    end)\n    self.Player = Players:GetPlayerFromCharacter(self.Instance) -- We find the Player from the bound Character instance and set it as a value within our Behavior.\nend\n\nfunction Behavior.DefaultMovement(self: AuroraScriptObject, deltaTime: number)\n    -- This function runs when BindToSimulation calls it with the deltaTime argument.\nend\n\n-- We declare a field in our Behavior to store the Player instance.\nBehavior.DeclareField(\"Player\", {Type = \"instance\"})\n</code></pre> <p>We now have a simple initial system that allows us to bind our method to the simulation and set our Player property.</p> <p>However, just like in the modular way, we need to create an input system to capture input from the client. Repeating the steps from Modular Way, we now have a hierarchy like this:</p> <p></p> <p>We can now move on to creating the actual system which will calculate the movement for the character.</p>"},{"location":"examples/character/#charactermovement_3","title":"CharacterMovement","text":"<pre><code>local RunService = game:GetService(\"RunService\")\nlocal Players = game:GetService(\"Players\")\n\ntype AuroraScriptObject = {\n    Instance: Instance,\n    Frame: number,\n    LODLevel: number,\n    Connect: (self: AuroraScriptObject, signal: RBXScriptSignal, functionName: string) -&gt; RBXScriptConnection,\n    Subscribe: (self: AuroraScriptObject, topic: string, functionName: string) -&gt; string,\n    Publish: (self: AuroraScriptObject, topic: string, ...any) -&gt; any,\n    SendMessage: (self: AuroraScriptObject, boundInstance: Instance, behaviorName: string, functionName: string, ...any) -&gt; ...any,\n    Delay: (self: AuroraScriptObject, amount: number, functionName: string) -&gt; string,\n    SetMaxFrequency: (self: AuroraScriptObject, frequency: number) -&gt; number,\n    [string]: any\n}\n\n-- This function runs when the Behavior starts.\nfunction Behavior.OnStart(self: AuroraScriptObject)\n    -- We bind the DefaultMovement method of the Behavior to the Simulation.\n    RunService:BindToSimulation(function(deltaTime: number) \n        self:DefaultMovement(deltaTime)\n    end)\n    self.Player = Players:GetPlayerFromCharacter(self.Instance) -- We find the Player from the bound Character instance and set it as a value within our Behavior.\nend\n\nfunction Behavior.DefaultMovement(self: AuroraScriptObject, deltaTime: number)\n    -- This function runs when BindToSimulation calls it with the deltaTime argument.\n\n    local Character: Model = self.Instance\n    local Player: Player = self.Player\n    if not Player then return end\n\n    local Humanoid: Humanoid = Character.Humanoid\n    if not Humanoid then return end\n\n    local Input: InputContext = Player.Input.Default\n\n    local MoveInput: InputAction = Input.Move\n    local CameraInput: InputAction = Input.Camera\n    local RotationInput: InputAction = Input.Rotation\n    local JumpInput: InputAction = Input.Jump\n\n    -- Getting the values from InputActions. We use :GetState() here instead of .StateChanged.\n    local MoveVector2D: Vector2 = MoveInput:GetState() \n    local CameraVector2D: Vector2 = CameraInput:GetState()\n    local RotationIsCameraRelative: boolean = RotationInput:GetState()\n    local JumpBoolean: boolean = JumpInput:GetState()\n\n    -- Calculating the move direction based on camera and movement input.\n    local CameraVector3D = Vector3.new(CameraVector2D.X, 0, CameraVector2D.Y)\n    local RightVector = CameraVector3D:Cross(Vector3.yAxis)\n\n    local MoveVector = CameraVector3D * MoveVector2D.Y + RightVector * MoveVector2D.X\n    local MoveDirection = Vector3.new(MoveVector.X, 0, MoveVector.Z)\n\n    -- Moving the Humanoid to the target move direction.\n    Humanoid:Move(MoveDirection)\n\n    -- Rotating the Character based on camera direction.\n    if RotationIsCameraRelative then\n        Humanoid.AutoRotate = false\n        if not Humanoid.SeatPart and Humanoid.RootPart then\n            Humanoid.RootPart.CFrame = CFrame.new(Humanoid.RootPart.CFrame.Position, Humanoid.RootPart.CFrame.Position + CameraVector3D)\n        end\n    else\n        Humanoid.AutoRotate = true\n    end\n\n    -- Allowing the Character to jump based on input, and if it's not currently in-air.\n    local currentState = Humanoid:GetState()\n    local isInAir = currentState == Enum.HumanoidStateType.FallingDown\n        or currentState == Enum.HumanoidStateType.Freefall\n        or currentState == Enum.HumanoidStateType.Jumping\n    if not isInAir and JumpBoolean then\n        Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)\n    end\nend\n\n-- We declare a field in our Behavior to store the Player instance.\nBehavior.DeclareField(\"Player\", {Type = \"instance\"})\n</code></pre> <p>Our behavior is now done! This behavior will now run when it has been bound to a player's character. To do this however, we need to manually bind it upon character load on the server. For this, we can add a <code>Script</code> called \"ServerSetup\".</p>"},{"location":"examples/character/#serversetup_1","title":"ServerSetup","text":"<pre><code>local Players = game:GetService(\"Players\")\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal ServerAuthority = ReplicatedStorage.ServerAuthority\nlocal Scripts = ServerAuthority.Scripts\nlocal Input = ServerAuthority.Input\n\n-- This function sets the streaming mode for the character model to Atomic, and binds the character to the behavior upon load.\nlocal function InitializeCharacter(character: Model)\n    character.ModelStreamingMode = Enum.ModelStreamingMode.Atomic\n    Scripts.Behavior:AddTo(character)\nend\n\n-- This function clones and parents the Input folder to the player to start capturing input.\nlocal function InitializePlayer(player: Player)\n    if player.Character then InitializeCharacter(player.Character) end\n    player.CharacterAdded:Connect(InitializeCharacter)\n\n    local InputTemplate = Input:Clone()\n    InputTemplate.Parent = player\nend\n\n-- This function initializes the above functions for all existing players, or new players.\nlocal function Initialize()\n    for _, player in Players:GetPlayers() do\n        InitializePlayer(player)\n    end\n    Players.PlayerAdded:Connect(InitializePlayer)\nend\n\n-- We want to only run the above systems when the AuthorityMode is set to Server. Automatic results in inconsistent behavior.\nif workspace.AuthorityMode == Enum.AuthorityMode.Server then\n    Initialize()\nend\n</code></pre> <p>This is our server script that parents the Input folder to a player, and binds the behavior to its character when it loads.</p> <p>With this system, the character can now move, however, we still need to create a client <code>Script</code> to capture input for the camera:</p>"},{"location":"examples/character/#camerainput_1","title":"CameraInput","text":"<pre><code>local Players = game:GetService(\"Players\")\nlocal RunService = game:GetService(\"RunService\")\nlocal UserGameSetting = UserSettings():GetService(\"UserGameSettings\")\n\nlocal LocalPlayer = Players.LocalPlayer\n\n-- Defining the InputActions for the camera and rotation.\nlocal Input = LocalPlayer:WaitForChild(\"Input\")\nlocal CameraInput: InputAction = Input.Default.Camera\nlocal RotationInput: InputAction = Input.Default.Rotation\n\nif workspace.AuthorityMode == Enum.AuthorityMode.Server then\n    -- This callback function calculates the current rotation of the character and the camera, and sends it to the server.\n    RunService:BindToRenderStep(\"CameraInput\", Enum.RenderPriority.Last.Value, function()\n        local Camera = workspace.CurrentCamera\n        local YAxis: Vector3 = Vector3.yAxis\n        local Forward = YAxis:Cross(Camera.CFrame.RightVector)\n\n        CameraInput:Fire(Vector2.new(Forward.X, Forward.Z))\n        RotationInput:Fire(UserGameSetting.RotationType == Enum.RotationType.CameraRelative)\n    end)\nend\n</code></pre> <p>After everything above has been complete, our new system hierarchy should now look like this:</p> <p></p> <p>And that's all! Hitting the \"Test\" button should allow you to test our new system. This new character system provides a secure and accurate character simulation, while behaving smoothly for the player's view.</p>"},{"location":"examples/admin/","title":"Basic Admin System","text":"<p>This is an example basic admin system that you can create and use with Server Authority.</p>"},{"location":"examples/admin/#the-design","title":"The Design","text":"<p>We will create a simple modular admin system, that contains some also simple command modules which allows the player to commit certain actions in the game. We can begin by creating a folder in <code>ReplicatedStorage</code>, which both the Server and the Client can access.</p> <p></p> <p>Next, we will create these instances:</p> <ul> <li> <p>\"CommandEvents\" <code>Folder</code>: This will hold our events which will allow the Server and the Client to communicate for the command modules. Such as when the command has been ran on the Server, the Server will fire an event which will tell the Client to also run the command.</p> </li> <li> <p>\"CommandScripts\" <code>Folder</code>: This will hold our Server and Client scripts which will run the command modules. You can edit these in any way you wish to customize the behavior of when and how will the command be ran.</p> </li> <li> <p>\"Commands\" <code>Folder</code>: This will hold our main command modules which will contain our simulation code for running the command. These modules will be ran on both the Server and the Client.</p> </li> <li> <p>\"Main\" <code>ModuleScript</code>: This is a module which essentially requires all the command modules and puts them in a simple API for usage. Instead of requiring each and individual command module, one can simply require this module and access the functions and data of all command modules through it. However, this module is purely for ease of use, and not necessary. You can also require the modules individually if you wish to customize that behavior, too.</p> </li> </ul> <p></p> <p>After setting our hierarchy, we can now set the Main module code:</p>"},{"location":"examples/admin/#main","title":"Main","text":"<pre><code>-- Written by @TenebrisNoctua\n-- Initializes and loads the command modules.\n\n--// Types\n\ntype ModuleReturnType = {\n    Begin: (player: Player, ...any) -&gt; (...any),\n    End: (player: Player, ...any) -&gt; (...any)?\n}\n\ntype function GetCommandsType(commandsFolder: type)\n    assert(commandsFolder:is(\"class\"), \"commandsFolder argument is not an extern type.\")\n    local commandsTable = types.newtable()\n    commandsTable:setindexer(types.string, types.any)\n\n    local properties = commandsFolder:properties()\n    for i, property in properties do\n        local name = i:value()\n        if name == \"Parent\" then continue end\n        commandsTable:setproperty(types.singleton(name), types.optional(ModuleReturnType))\n    end\n\n    return commandsTable\nend\n\n--// Main Initialization\n\nlocal CommandsFolder = script.Parent:FindFirstChild(\"Commands\")\nassert(CommandsFolder, \"Cannot find the commands folder.\")\n\nlocal CommandModules = CommandsFolder:GetChildren()\nlocal GlobalCommands: GetCommandsType&lt;typeof(CommandsFolder)&gt; = {}\n\nfor _, moduleScript in CommandModules do\n    if not moduleScript:IsA(\"ModuleScript\") then continue end\n    local success, commandModule = pcall(require, moduleScript)\n    if success then\n        GlobalCommands[moduleScript.Name] = commandModule\n    else\n        warn(\"Failed to require command module:\", moduleScript.Name)\n    end\nend\n\nreturn GlobalCommands\n</code></pre> <p>This module will now allow us to easily access the command modules with a simple to use API system.</p> <p>Now that we have set-up our main admin system, we can begin adding our command modules and scripts. To do so, you can check out the basic command tutorial pages on the left side. You may use them to learn how to implement some basic general commands.</p>"},{"location":"examples/admin/fly/","title":"Fly Command","text":"<p>This is an example basic fly command that allows the players to fly in the direction of their camera.</p>"},{"location":"examples/admin/fly/#the-design","title":"The Design","text":"<p>We will create a command module, an event, and scripts to allow a certain player's character to fly in the game. We can begin by creating a new command module under the \"Commands\" folder in our admin system folder.</p> <p></p>"},{"location":"examples/admin/fly/#fly","title":"Fly","text":"<pre><code>-- Written by @TenebrisNoctua\n-- Makes the given player fly.\n\n--// Variables\n\nlocal RunService = game:GetService(\"RunService\")\n\nlocal AdminModule = {\n    Speed = 20, -- How fast a player will fly. (Studs per second)\n    Flying = {} :: {[Instance]: {RBXScriptConnection}} -- Stores the currently flying players, and their connections.\n}\n\n--// Types\n\ntype TPlayer = {\n    InputContexts: {\n        Character: {\n            Camera: InputAction,\n            CameraPosition: InputAction,\n            Move: InputAction,\n            Jump: InputAction\n        } &amp; InputContext\n    } &amp; Folder\n} &amp; Player\n\n--// Module Functions\n\n-- This is the main command module function that when ran, allows the target player to fly.\nfunction AdminModule.Begin(player: TPlayer)\n    if not player:FindFirstChild(\"InputContexts\") then return end\n    if AdminModule.Flying[player] then return end -- We check if the player is already flying or not.\n\n    local Character = player.Character\n    if not Character then return end\n\n    local HumanoidRootPart = Character:FindFirstChild(\"HumanoidRootPart\") :: BasePart\n    if not HumanoidRootPart then return end\n\n    local AlignPosition: AlignPosition\n    local AlignOrientation: AlignOrientation\n    local CameraPosition: InputAction\n\n    -- Here, we create the necessary instances that will allow the character to fly, if the module is ran on the server. These instances are used to align the player to a specific location at a specific orientation.\n    if RunService:IsServer() then\n        AlignPosition = Instance.new(\"AlignPosition\")\n        AlignPosition.ApplyAtCenterOfMass = true\n        AlignPosition.Mode = Enum.PositionAlignmentMode.OneAttachment\n        AlignPosition.Attachment0 = HumanoidRootPart:WaitForChild(\"RootAttachment\") :: Attachment\n        AlignPosition.Position = HumanoidRootPart.Position\n        AlignPosition.Parent = HumanoidRootPart\n\n        AlignOrientation = Instance.new(\"AlignOrientation\")\n        AlignOrientation.Mode = Enum.OrientationAlignmentMode.OneAttachment\n        AlignOrientation.Attachment0 = HumanoidRootPart:WaitForChild(\"RootAttachment\") :: Attachment\n        AlignOrientation.Responsiveness = 50\n        AlignOrientation.Parent = HumanoidRootPart\n\n        -- Here, we create a new InputAction that captures the camera position of the client. The server will recieve and use this position to calculate the orientation of the character.\n        CameraPosition = Instance.new(\"InputAction\")\n        CameraPosition.Type = Enum.InputActionType.Direction3D\n        CameraPosition.Name = \"CameraPosition\"\n        CameraPosition.Parent = player.InputContexts.Character\n    else\n        -- We do not need to create these instances on the client, as they will be replicated anyway. We just need to locate them.\n        AlignPosition = HumanoidRootPart:FindFirstChild(\"AlignPosition\") :: AlignPosition\n        AlignOrientation = HumanoidRootPart:FindFirstChild(\"AlignOrientation\") :: AlignOrientation\n        CameraPosition = player.InputContexts.Character.CameraPosition\n    end\n\n    local CharacterContext = player.InputContexts.Character\n    local Humanoid = Character:FindFirstChild(\"Humanoid\") :: Humanoid\n    Humanoid.PlatformStand = true\n\n    local Connections = {}\n\n    if RunService:IsClient() then\n        -- This is used to send the current camera position to the server, so both the server and the client can use this data to calculate the correct orientation of the character.\n        table.insert(Connections, RunService.RenderStepped:Connect(function(deltaTime: number)\n            local CurrentCamera = game.Workspace.CurrentCamera\n            if not CurrentCamera then return end\n            CameraPosition:Fire(CurrentCamera.CFrame.Position)  \n        end))\n    end\n\n    table.insert(Connections, RunService:BindToSimulation(function(deltaTime: number)\n        -- Here, we get the camera position, and using it, calculate the target position and the orientation of the character.\n        -- This function is bound to the simulation, and is ran on both the server and the client.\n        local CameraPosition: Vector3 = CameraPosition:GetState()\n        AlignPosition.Position = HumanoidRootPart.Position + ((HumanoidRootPart.Position - CameraPosition).Unit * AdminModule.Speed)\n        AlignOrientation.CFrame = CFrame.lookAt(CameraPosition, HumanoidRootPart.Position)\n    end))\n\n    AdminModule.Flying[player] = Connections -- We add the player to the table to indicate that they're now flying.\nend\n\n-- This is the other main command module function that when ran, stops the target player from flying.\nfunction AdminModule.End(player: TPlayer)\n    local Connections = AdminModule.Flying[player]\n    if not Connections then return end -- If the player is not flying, don't do anything.\n\n    if RunService:IsClient() then\n        -- The client does not need to destroy the instances due to replication.\n        -- We just need to disconnect the events and clean-up.\n        for _, connection in Connections do\n            connection:Disconnect()\n        end\n        table.clear(Connections)\n        AdminModule.Flying[player] = nil -- We remove the player from the table, now that they're no longer flying, on the client.\n        return\n    end\n\n    -- The server will both destroy the created instances, and do the clean-up on its part.\n\n    local Character = player.Character\n    if not Character then player.CharacterAdded:Wait(); Character = player.Character end\n    if not Character then return end\n\n    local CharacterContext = player.InputContexts.Character\n\n    local HumanoidRootPart = Character:FindFirstChild(\"HumanoidRootPart\")\n    local AlignPosition = HumanoidRootPart:FindFirstChild(\"AlignPosition\")\n    local AlignOrientation = HumanoidRootPart:FindFirstChild(\"AlignOrientation\")\n    local Humanoid = Character:FindFirstChild(\"Humanoid\") :: Humanoid\n\n    Humanoid.PlatformStand = false\n\n    for _, connection in Connections do\n        connection:Disconnect()\n    end\n    table.clear(Connections)\n\n    AlignPosition:Destroy()\n    AlignOrientation:Destroy()\n    CharacterContext.CameraPosition:Destroy()\n\n    AdminModule.Flying[player] = nil -- We remove the player from the table, now that they're no longer flying, on the server.\nend\n\nreturn AdminModule\n</code></pre> <p>Our simulation and main flying system code is now ready. Now, we need to create initializer scripts to run this code on both the Server and the Client. To achieve that, we can create two new <code>Script</code>s in the \"CommandScripts\" folder.</p> <p></p> <p>Before we move on to implementing the code for these <code>Script</code>s, we also need to create a new <code>RemoteEvent</code> that allows the client <code>Script</code> to know when to start or stop the command module. We can create a new <code>RemoteEvent</code> for this under the \"CommandEvents\" folder.</p> <p></p> <p>Now that our events and other instances are set, we can start by implementing our Client <code>Script</code> which will start the command module once the \"Fly\" event has been fired.</p>"},{"location":"examples/admin/fly/#client","title":"Client","text":"<pre><code>-- Written by @TenebrisNoctua\n-- Handles the relevant command event.\n\n--// Variables\n\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Players = game:GetService(\"Players\")\nlocal StarterPlayer = game:GetService(\"StarterPlayer\")\n\nlocal PlayerModule = require(StarterPlayer:WaitForChild(\"PlayerModule\"))\nlocal Controls = PlayerModule:GetControls()\n\nlocal AdminSystem = ReplicatedStorage.AdminSystem\nlocal CommandEvents = AdminSystem.CommandEvents\n\nlocal FlyCommand = require(AdminSystem.Main).Fly\nlocal FlyEvent = CommandEvents.Fly\n\n--// Event Handler\n\n-- This event will be fired with a string that allows the client to know which operation to perform.\nFlyEvent.OnClientEvent:Connect(function(state: string)\n    if not Players.LocalPlayer then return end\n    if not FlyCommand then return end\n    if state == \"Begin\" then -- If the state is \"Begin\", then begin the simulation.\n        Controls:Enable(false) -- We disable the player controls here to make sure it doesn't conflict with our system.\n        FlyCommand.Begin(Players.LocalPlayer :: any) -- Our main command module function that begins the simulation.\n    elseif state == \"End\" then -- If the state is \"End\", then end the simulation.\n        if not FlyCommand.End then return end\n        FlyCommand.End(Players.LocalPlayer :: any) -- Our other main command module function that ends the simulation.\n        Controls:Enable(true) -- We enable the player controls afterwards so the player can move normally again.\n    end\nend)\n</code></pre> <p>We are almost done! All we need to do is to implement the code that will run the command module on the Server as well.</p>"},{"location":"examples/admin/fly/#server","title":"Server","text":"<pre><code>-- Written by @TenebrisNoctua\n-- Handles the relevant command system.\n\n--// Variables\n\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nlocal Players = game:GetService(\"Players\")\n\nlocal AdminSystem = ReplicatedStorage.AdminSystem\nlocal CommandEvents = AdminSystem.CommandEvents\n\nlocal FlyCommand = require(AdminSystem.Main).Fly\nlocal FlyEvent = CommandEvents.Fly\n\n--// Local Function\n\n-- This function runs when a player has joined the server.\nlocal function onPlayerAdded(player: Player)\n    if not FlyCommand then return end   \n    player.CharacterAdded:Wait() -- We wait until the player has a character.\n\n    FlyCommand.Begin(player) -- We begin the simulation for the player on the server.\n    FlyEvent:FireClient(player, \"Begin\") -- Then, we send the signal to the client to begin with its own simulation.\n\n    task.wait(10) -- Waiting 10 seconds to allow the player to test the feature.\n    if not FlyCommand.End then return end\n    FlyCommand.End(player) -- We end the simulation for the player on the server.\n    FlyEvent:FireClient(player, \"End\") -- Then, we send the signal to the client to stop with its own simulation.\nend\n\n-- This exists just in-case if the below event does not fire.\nfor _, player in Players:GetPlayers() do\n    onPlayerAdded(player)\nend\n\n--// Event Handler\n\nPlayers.PlayerAdded:Connect(onPlayerAdded)\n</code></pre> <p>And that's all! Hitting the \"Play\" button should allow you to test our new admin command. You are free to change the Server code as much as you like, to implement an input-based system where the player can press certain keys, or use a certain command string, to start or stop flying.</p>"},{"location":"main/aurora/","title":"Behaviors","text":"<p>Warning</p> <p>The <code>Instance</code> and the Service mentioned in this page cannot be accessed without configuring certain flags. This <code>Instance</code> is also in heavy development and is not currently recommended for work.</p>"},{"location":"main/aurora/#what-are-behaviors","title":"What are Behaviors?","text":"<p>In the Server Authority system, you need to simulate the physics and controls for a certain <code>Instance</code> on both the server and the client simultaneously. This is what allows the systems explained in the previous pages to work.</p> <p>To achieve this, there are two ways one can go on about, such as creating a multi-script architecture, where exists a <code>ModuleScript</code> which exports a method that runs the simulation for the <code>Instance</code>, that is then required and ran by both the server and the client. Or a single-script architecture, where one or more <code>Script</code>s do the same thing. Regardless of which way one can go on about, it is not convenient to do this system in multiple <code>Script</code>s just to be able to run the same system on both the server and the client. These <code>Script</code>s may also run into certain issues such as yielding.</p> <p>Luckily for us, there exists a work-in-progress <code>Instance</code> that makes it more convenient for us to run the same simulation on both the server and the client, while ensuring that our <code>Script</code>s will not run into any yielding issues. It allows us to define Behaviors, which are systems that run the same code on both the server and the client simultaneously, and can be bound to <code>Instance</code>s.</p>"},{"location":"main/aurora/#aurorascript","title":"AuroraScript","text":"<p>This <code>Instance</code> that I've mentioned above is called <code>AuroraScript</code>. This new script <code>Instance</code> allows you to define those Behaviors that can be bound to other <code>Instance</code>s and operate on them. </p> <p>Note</p> <p>In the future, the class name \"AuroraScript\" will most likely be replaced with \"BehaviorScript\".</p> <p>Unlike the other script <code>Instance</code>s, <code>AuroraScript</code> has certain limitations placed within its environment. There are a few reasons for this, ranging from optimization, to ensuring the thread does not yield, and to Behaviors to smoothly interact with other Behaviors and run within the world.</p>"},{"location":"main/aurora/#limitations","title":"Limitations","text":"<ul> <li>All <code>AuroraScript</code>s in the same location (e.g, <code>workspace</code>) must have a different name. Otherwise, one of them will not run.</li> <li>Certain APIs and global libraries do not work in the environment of an <code>AuroraScript</code>. The ones I'm aware of at the moment are:<ul> <li>All methods of the <code>task</code> library (Except for <code>task.cancel()</code>).</li> <li><code>RunService:IsClient()</code> and <code>RunService:IsServer()</code>.</li> <li><code>coroutine.yield()</code> (Behaviors cannot yield.)</li> </ul> </li> </ul> <p>Besides the limitations, generally <code>AuroraScript</code>s should always be parented to a location that can be both accessed from the client and the server, such as <code>ReplicatedStorage</code>. If you parent an <code>AuroraScript</code> to a location such as <code>ServerScriptStorage</code>, this will cause it to only run on the server, and not the client.</p>"},{"location":"main/aurora/#methods","title":"Methods","text":""},{"location":"main/aurora/#aurorascriptaddtoinstance-instance","title":"<code>AuroraScript:AddTo(instance: Instance): ()</code>","text":"<p>This method binds the Behavior <code>AuroraScript</code> to the specified <code>Instance</code>. This then calls the (if defined) <code>.OnStart</code> method of the Behavior.</p> <p>Note</p> <p>Behaviors can also be bound manually, without the need of this method. With the Server Authority feature enabled, the Properties widget gain a new section for every <code>Instance</code>, called: \"Behaviors\". Clicking the \"+\" button on this section will allow you to find and bind any Behavior on an <code>Instance</code>.</p>"},{"location":"main/aurora/#aurorascriptremovefrominstance-instance","title":"<code>AuroraScript:RemoveFrom(instance: Instance): ()</code>","text":"<p>This method removes the Behavior <code>AuroraScript</code> from the specified <code>Instance</code>.</p>"},{"location":"main/aurora/#aurorascriptisoninstanceinstance-instance","title":"<code>AuroraScript:IsOnInstance(instance: Instance): ()</code>","text":"<p>This method allows you to check if the Behavior <code>AuroraScript</code> is on the specified <code>Instance</code>.</p>"},{"location":"main/aurora/#aurorascriptsignalfiredinstance-instance-topic-string-rbxscriptsignal","title":"<code>AuroraScript:SignalFired(instance: Instance, topic: string): RBXScriptSignal</code>","text":"<p>This method allows you to create a Signal that is fired when the <code>AuroraScriptObject</code> of the <code>AuroraScript</code> publishes a value with a topic.</p>"},{"location":"main/aurora/#the-behavior-data-type","title":"The Behavior Data Type","text":"<p>Every <code>AuroraScript</code> comes with a global data type called <code>Behavior</code>, which can be accessed everywhere from the script. We use this data type to define our methods which will run the simulation system.</p> <p>Info</p> <p>The term \"Behavior\" represents an <code>AuroraScript</code>. <code>AuroraScript</code>s do not have Behaviors, they are the Behaviors themselves. In certain places, for example the \"Behaviors\" section in the Properties window, this is more apparent.</p> <p>Warning</p> <p>Every Behavior must be bound to an <code>Instance</code> for them to work.</p> <p>There are certain methods you have to define in the Behavior for it to start working. They are listed below.</p>"},{"location":"main/aurora/#behavioronstartself-aurorascriptobject","title":"<code>Behavior.OnStart(self: AuroraScriptObject): ()</code>","text":"<p>This is a special method that you can define in the Behavior, which runs when the Behavior has been started. It allows you to connect certain events to certain methods and set certain field values, which are explained below.</p> <pre><code>function Behavior.OnStart(self: AuroraScriptObject)\n    print(self)\nend\n</code></pre> <p>You might've noticed that <code>.OnStart</code> has a parameter called <code>self</code>, which is an <code>AuroraScriptObject</code>. This is the object that is given to every function that you define in the Behavior. It will be explained in detail in the next section.</p> <p>Info</p> <p>Behaviors are started when the physics simulation begins, if they've already been bound to an <code>Instance</code> before the simulation. If not, then Behaviors are started after <code>:AddTo()</code> has been called on them, or if they've been manually bound to an <code>Instance</code> in the Properties widget.</p>"},{"location":"main/aurora/#behavioronstopself-aurorascriptobject","title":"<code>Behavior.OnStop(self: AuroraScriptObject): ()</code>","text":"<p>This is a special method that you can define in the Behavior, which runs when the Behavior has been stopped.</p> <pre><code>function Behavior.OnStop(self: AuroraScriptObject)\n    print(self)\nend\n</code></pre> <p>Info</p> <p>Behaviors are stopped when the Physics simulation ends, if they've already been started. If not, then Behaviors are stopped when <code>:RemoveFrom()</code> has been called on them, or if they've been manually removed from an <code>Instance</code> in the Properties widget.</p>"},{"location":"main/aurora/#behaviordeclarefieldfieldname-string-_-type-boolean-cframe-color3-enum-instance-number-random-vector2-vector3","title":"<code>Behavior.DeclareField(fieldName: string, _: { Type: \"boolean\" | \"cframe\" | \"color3\" | \"enum\" | \"instance\" | \"number\" | \"random\" | \"vector2\" | \"vector3\" }): ()</code>","text":"<p>This method allows you to define a field with a certain type in the <code>AuroraScriptObject</code>. The defined field will appear as a property within the <code>AuroraScriptObject</code>.</p>"},{"location":"main/aurora/#behaviorexportmethodmethodname-string","title":"<code>Behavior.ExportMethod(methodName: string)</code>","text":"<p>This method allows you to export a defined method in the data type. Do note that you must call this after the method with the specified <code>methodName</code> has been declared, otherwise, it will error.</p>"},{"location":"main/aurora/#aurorascriptobject","title":"AuroraScriptObject","text":"<p>This is the object given to the every function defined in the Behavior. It has certain properties and methods that allows you to do things such as publishing and sending values and messages across Behaviors, and more. </p> <pre><code>type AuroraScriptObject = {\n    Instance: Instance,\n    Frame: number,\n    LODLevel: number,\n    Connect: (self: AuroraScriptObject, signal: RBXScriptSignal, functionName: string) -&gt; RBXScriptConnection,\n    Subscribe: (self: AuroraScriptObject, topic: string, functionName: string) -&gt; string,\n    Publish: (self: AuroraScriptObject, topic: string, ...any) -&gt; any,\n    SendMessage: (self: AuroraScriptObject, boundInstance: Instance, behaviorName: string, functionName: string, ...any) -&gt; ...any,\n    Delay: (self: AuroraScriptObject, amount: number, functionName: string) -&gt; string,\n    SetMaxFrequency: (self: AuroraScriptObject, frequency: number) -&gt; number\n}\n\nfunction Behavior.OnStart(self: AuroraScriptObject)\n    print(self) -- prints the AuroraScriptObject\nend\n</code></pre> <p>Now be warned, unlike any other object which is found in the Roblox API, <code>AuroraScriptObject</code> does not reflect the properties found in the API dump. Even when you print this object, it does not give you any property names that allows you to directly access a certain value.</p> <p>An example:</p> <pre><code>{\n    [Attached Instance] = Part,\n    [Behavior] = AuroraScript,\n    [Frame ID] = 509,\n    [self] =  \u25b6 {...}\n}\n</code></pre> <p>This is a detailed string that shows you information about the <code>AuroraScriptObject</code>, such as which frame it currently is on, the Behavior it is from, the bound instance, and lastly, the <code>self</code> table, which is used to show you the declared fields made with <code>Behavior.DeclareField()</code> function. (These field properties can be accessed through indexing the <code>AuroraScriptObject</code> with their name.)</p> <p>Unfortunately, you cannot access these properties directly, and most likely this information is only shown for debugging purposes. In the previous example however, you might have noticed that I've added an <code>AuroraScriptObject</code> type which contains information about all of the currently known and actually accessible methods and properties of the <code>AuroraScriptObject</code>.  (Of course, I have found these properties using reverse-engineering methods.) They are described in detail below.</p>"},{"location":"main/aurora/#properties","title":"Properties","text":""},{"location":"main/aurora/#aurorascriptobjectinstance","title":"<code>AuroraScriptObject.Instance</code>","text":"<p>This is the <code>Instance</code> that the Behavior is bound to.</p>"},{"location":"main/aurora/#aurorascriptobjectframe","title":"<code>AuroraScriptObject.Frame</code>","text":"<p>The current Frame the world is on. Most likely changes after Heartbeat or PreAnimation.</p>"},{"location":"main/aurora/#aurorascriptobjectlodlevel","title":"<code>AuroraScriptObject.LODLevel</code>","text":"<p>The level of distance number of the Behavior. Not sure what it is supposed to be used for at the moment.</p>"},{"location":"main/aurora/#methods_1","title":"Methods","text":""},{"location":"main/aurora/#aurorascriptobjectconnectself-aurorascriptobject-signal-rbxscriptsignal-functionname-string-rbxscriptconnection","title":"<code>AuroraScriptObject.Connect:(self: AuroraScriptObject, signal: RBXScriptSignal, functionName: string) -&gt; RBXScriptConnection</code>","text":"<p>This method allows you to connect to a certain given <code>RBXScriptSignal</code>. The <code>functionName</code> argument must be the name of a function in the Behavior.</p> <pre><code>local RunService = game:GetService(\"RunService\")\n\ntype AuroraScriptObject = {\n    Instance: Instance,\n    Frame: number,\n    LODLevel: number,\n    Connect: (self: AuroraScriptObject, signal: RBXScriptSignal, functionName: string) -&gt; RBXScriptConnection,\n    Subscribe: (self: AuroraScriptObject, topic: string, functionName: string) -&gt; string,\n    Publish: (self: AuroraScriptObject, topic: string, ...any) -&gt; any,\n    SendMessage: (self: AuroraScriptObject, boundInstance: Instance, behaviorName: string, functionName: string, ...any) -&gt; ...any,\n    Delay: (self: AuroraScriptObject, amount: number, functionName: string) -&gt; string,\n    SetMaxFrequency: (self: AuroraScriptObject, frequency: number) -&gt; number\n}\n\nfunction Behavior.OnStart(self: AuroraScriptObject)\n    self:Connect(RunService.Heartbeat, \"Test\")\nend\n\nfunction Behavior.Test(self: AuroraScriptObject, deltaTime: number) -- This method will get called whenever the .Heartbeat event fires.\n    print(self, deltaTime)\nend\n</code></pre> <p>Warning</p> <p><code>.Connect</code> can only be called in the <code>.OnStart</code> function. Attempting to call this function anywhere else will cause an error.</p>"},{"location":"main/aurora/#aurorascriptobjectsubscribeself-aurorascriptobject-topic-string-functionname-string-string","title":"<code>AuroraScriptObject.Subscribe(self: AuroraScriptObject, topic: string, functionName: string) -&gt; string</code>","text":"<p>This method allows you to subcribe to a published value in the Behavior with a certain <code>topic</code>. The <code>functionName</code> must be the name of a function in the Behavior.</p> <p>The subcribed function will always have 2 arguments by default, the self <code>AuroraScriptObject</code> and the bound <code>Instance</code>. Additional arguments will come after. Calling this method will return the value of the <code>topic</code> parameter.</p> <p>Warning</p> <p>This function can only be called in <code>.OnStart</code>.</p>"},{"location":"main/aurora/#aurorascriptobjectpublishself-aurorascriptobject-topic-string-any-any","title":"<code>AuroraScriptObject.Publish(self: AuroraScriptObject, topic: string, ...any) -&gt; any</code>","text":"<p>This method allows you to publish a value in the Behavior with a certain <code>topic</code>. The last argument given to this method will be returned as a value.</p> <p>Warning</p> <p>This function cannot be called in <code>.OnStart</code>.</p> <pre><code>local RunService = game:GetService(\"RunService\")\n\ntype AuroraScriptObject = {\n    Instance: Instance,\n    Frame: number,\n    LODLevel: number,\n    Connect: (self: AuroraScriptObject, signal: RBXScriptSignal, functionName: string) -&gt; RBXScriptConnection,\n    Subscribe: (self: AuroraScriptObject, topic: string, functionName: string) -&gt; string,\n    Publish: (self: AuroraScriptObject, topic: string, ...any) -&gt; any,\n    SendMessage: (self: AuroraScriptObject, boundInstance: Instance, behaviorName: string, functionName: string, ...any) -&gt; ...any,\n    Delay: (self: AuroraScriptObject, amount: number, functionName: string) -&gt; string,\n    SetMaxFrequency: (self: AuroraScriptObject, frequency: number) -&gt; number\n}\n\nfunction Behavior.OnStart(self: AuroraScriptObject)\n    self:Subscribe(\"Test\", \"GetPublishedValue\")\n    self:Connect(RunService.Heartbeat, \"OnHeartbeat\")\nend\n\nfunction Behavior.OnHeartbeat(self: AuroraScriptObject, deltaTime: number)\n    self:Publish(\"Test\", \"Hello!\")\nend\n\nfunction Behavior.GetPublishedValue(self: AuroraScriptObject, boundInstance: Instance, recievedValue: any)\n    print(boundInstance, recievedValue) -- Instance, Hello!\nend\n</code></pre>"},{"location":"main/aurora/#aurorascriptobjectsendmessageself-aurorascriptobject-boundinstance-instance-behaviorname-string-functionname-string-any-any","title":"<code>AuroraScriptObject.SendMessage(self: AuroraScriptObject, boundInstance: Instance, behaviorName: string, functionName: string, ...any) -&gt; ...any</code>","text":"<p>This method allows you to communicate with other Behaviors in a world. When sending a message, you must specify the <code>Instance</code> that a Behavior is bound to, the name of the Behavior, and the name of the function you want to send this message to. Then, you can add additional values as arguments to send to the function.</p>"},{"location":"main/aurora/#sending-and-recieving-messages","title":"Sending and Recieving Messages","text":"<p>Let's assume we have 2 <code>AuroraScript</code>s in the <code>workspace</code> called: \"Test_1\", and \"Test_2\". And let's also assume we have 2 <code>Part</code>s these Behavior <code>AuroraScript</code>s are bound to.</p> <p>Our system would be like this:</p> <p>Test_1 --&gt; Part Test_2 --&gt; Part_2</p> <p>If we wanted to send a message from Test_1 to Test_2, how would we do it? This is where <code>:SendMessage()</code> comes in. Using this method, we can send and recieve messages across different Behaviors.</p>"},{"location":"main/aurora/#test_1","title":"Test_1:","text":"<pre><code>local RunService = game:GetService(\"RunService\")\n\ntype AuroraScriptObject = {\n    Instance: Instance,\n    Frame: number,\n    LODLevel: number,\n    Connect: (self: AuroraScriptObject, signal: RBXScriptSignal, functionName: string) -&gt; RBXScriptConnection,\n    Subscribe: (self: AuroraScriptObject, topic: string, functionName: string) -&gt; string,\n    Publish: (self: AuroraScriptObject, topic: string, ...any) -&gt; any,\n    SendMessage: (self: AuroraScriptObject, boundInstance: Instance, behaviorName: string, functionName: string, ...any) -&gt; ...any,\n    Delay: (self: AuroraScriptObject, amount: number, functionName: string) -&gt; string,\n    SetMaxFrequency: (self: AuroraScriptObject, frequency: number) -&gt; number\n}\n\nfunction Behavior.OnStart(self: AuroraScriptObject)\n    self:Connect(RunService.Heartbeat, \"OnHeartbeat\")\nend\n\nfunction Behavior.OnHeartbeat(self: AuroraScriptObject, deltaTime: number)\n    self:SendMessage(game.Workspace.Part_2, \"Test_2\", \"Test\", \"Hello!\")\nend\n</code></pre>"},{"location":"main/aurora/#test_2","title":"Test_2","text":"<pre><code>local RunService = game:GetService(\"RunService\")\n\ntype AuroraScriptObject = {\n    Instance: Instance,\n    Frame: number,\n    LODLevel: number,\n    Connect: (self: AuroraScriptObject, signal: RBXScriptSignal, functionName: string) -&gt; RBXScriptConnection,\n    Subscribe: (self: AuroraScriptObject, topic: string, functionName: string) -&gt; string,\n    Publish: (self: AuroraScriptObject, topic: string, ...any) -&gt; any,\n    SendMessage: (self: AuroraScriptObject, boundInstance: Instance, behaviorName: string, functionName: string, ...any) -&gt; ...any,\n    Delay: (self: AuroraScriptObject, amount: number, functionName: string) -&gt; string,\n    SetMaxFrequency: (self: AuroraScriptObject, frequency: number) -&gt; number\n}\n\nfunction Behavior.OnStart(self: AuroraScriptObject)\n    self:Connect(RunService.Heartbeat, \"OnHeartbeat\")\nend\n\nfunction Behavior.OnHeartbeat(self: AuroraScriptObject, deltaTime: number) end\n\nfunction Behavior.OnMessageTest(self: AuroraScriptObject, recievedMessage: string)\n    warn(recievedMessage) -- \"Hello!\"\nend\n</code></pre> <p>Warning</p> <p>All functions recieving a message must have a name that starts with \"OnMessage\". For example, if we call the <code>:SendMessage()</code> with a <code>functionName</code> argument called \"Test\", then the function name must be \"OnMessageTest\" on the recieving Behavior.</p>"},{"location":"main/aurora/#aurorascriptobjectdelayself-aurorascriptobject-amount-number-functionname-string-string","title":"<code>AuroraScriptObject.Delay(self: AuroraScriptObject, amount: number, functionName: string): string</code>","text":"<p>This method allows you to run a function in the Behavior with a certain amount of delay. (In seconds)</p>"},{"location":"main/aurora/#aurorascriptobjectsetmaxfrequencyself-aurorascriptobject-frequency-number-number","title":"<code>AuroraScriptObject.SetMaxFrequency(self: AuroraScriptObject, frequency: number): number</code>","text":"<p>This method allows you to set the maximum amount of frequency the <code>AuroraScriptObject</code> can run with. Must be a value between 1 to 60.</p>"},{"location":"main/aurora/#aurorascriptservice","title":"AuroraScriptService","text":"<p>This service is meant to manage and communicate with Behavior <code>AuroraScript</code>s.</p>"},{"location":"main/aurora/#methods_2","title":"Methods","text":""},{"location":"main/aurora/#aurorascriptservicesendmessageinstance-instance-behaviorname-string-functionname-string-any","title":"<code>AuroraScriptService:SendMessage(instance: Instance, behaviorName: string, functionName: string, ...: any): ()</code>","text":"<p>This method works exactly the same as the <code>AuroraScriptObject:SendMessage()</code>, except it is used outside of Behaviors to send messages to Behaviors. The same rules apply.</p>"},{"location":"main/aurora/#aurorascriptservicegetbehaviors-aurorascript","title":"<code>AuroraScriptService:getBehaviors(): {AuroraScript}</code>","text":"<p>This method returns a table containing all of the Behaviors in the place.</p>"},{"location":"main/aurora/#aurorascriptservicegetbehaviorsforinstanceinstance-instance-aurorascript","title":"<code>AuroraScriptService:getBehaviorsForInstance(instance: Instance): {AuroraScript}</code>","text":"<p>This method returns a table containing all of the Behaviors bound to the specified <code>Instance</code>.</p>"},{"location":"main/aurora/#aurorascriptservicegetinstancesforbehaviorbehavior-aurorascript-instance","title":"<code>AuroraScriptService:getInstancesForBehavior(behavior: AuroraScript): {Instance}</code>","text":"<p>This method returns a table containing all of the <code>Instance</code>s that the specified Behavior is bound to.</p>"},{"location":"main/aurora/#aurorascriptservicefindbindingsinstance-instance-string-any","title":"<code>AuroraScriptService:FindBindings(instance: Instance): { [string]: any }</code>","text":"<p>This method returns a table containing all of the <code>AuroraScriptObject</code>s from the Behaviors bound to an <code>Instance</code>. Can only be used within <code>AuroraScript</code>s.</p>"},{"location":"main/aurora/#aurorascriptservicefindbindinginstance-instance-scriptname-string-aurorascriptobject","title":"<code>AuroraScriptService:FindBinding(instance: Instance, scriptName: string): AuroraScriptObject</code>","text":"<p>This method returns the <code>AuroraScriptObject</code> from the target Behavior (with the <code>scriptName</code>) bound to an <code>Instance</code>. Can only be used within <code>AuroraScript</code>s.</p>"},{"location":"main/aurora/#aurorascriptservicegetlocalframeid-number","title":"<code>AuroraScriptService:GetLocalFrameId(): number</code>","text":"<p>This method returns a number that presumably indicates the current frame of the world.</p>"},{"location":"main/credits/","title":"Closing Thoughts","text":"<p>That's all! Hopefully I could explain these new features well. If you have any questions or things to share, please contact me through my Twitter or DevForum. I may update this documentation with more information whenever I find them. Cheers!</p>"},{"location":"main/credits/#credits","title":"Credits","text":""},{"location":"main/credits/#noctua-tenebrisnoctua-on-twitter","title":"Noctua (@TenebrisNoctua on Twitter)","text":""},{"location":"main/credits/#max-maximumadhd-on-twitter","title":"Max (@MaximumADHD on Twitter)","text":""},{"location":"main/credits/#aztup-realaztup-on-twitter","title":"Aztup (@RealAztup on Twitter)","text":""},{"location":"main/credits/#x64-walletoverflow-on-devforum","title":"x64 (@WalletOverflow on DevForum)","text":""},{"location":"main/credits/#welblander-welblander-on-devforum","title":"welblander (@welblander on DevForum)","text":""},{"location":"main/howto/","title":"Working with Server Authority","text":"<p>Roblox has created certain <code>Workspace</code> properties that you can configure to enable all or certain parts of Server Authority. They are listed below.</p> <ul> <li><code>Workspace &gt; UseFixedSimulation</code>: Enables/Disables <code>RunService:BindToSimulation()</code>.</li> <li><code>Workspace &gt; PlayerScriptsUseInputActionSystem</code>: Updates the built in Player scripts to a new model where they live under <code>StarterPlayer</code>, use the Input Action System, and allow the Server to process player inputs.</li> <li><code>Workspace &gt; NextGenerationReplication</code>: Enables/Disables a new replication system that alters and improves how properties are replicated under the hood. Note that this system is fully disconnected from remote events so you should not rely on the ordering of property replication and remote events.</li> <li><code>Workspace &gt; Server Authority &gt; AuthorityMode</code>: Allows you to set the authority mode of the place. </li> </ul> <p>Warning</p> <p>Setting the <code>AuthorityMode</code> to <code>Server</code> will automatically enable all of the properties above, and change certain other workspace properties. Below is a list of all properties that will be changed.</p> <ul> <li><code>Workspace &gt; StreamingEnabled</code>: <code>Enabled</code></li> <li><code>Workspace &gt; SignalBehavior</code>: <code>Deferred</code></li> <li><code>Workspace &gt; Behavior &gt; PhysicsSteppingMethod</code>: <code>Fixed</code></li> <li><code>Workspace &gt; UseFixedSimulation</code>: <code>Enabled</code></li> <li><code>Workspace &gt; PlayerScriptsUseInputActionSystem</code>: <code>Enabled</code></li> <li><code>Workspace &gt; NextGenerationReplication</code>: <code>Enabled</code></li> </ul> <p>These properties cannot be changed while the <code>AuthorityMode</code> is set to <code>Server</code>.</p> <p>After configuring the properties above, Server Authority should now be ready for usage.</p> <p>If you wish to simply enable Server Authority for your characters and parts in your game, and you do not have systems dependant on how these characters and parts behave on your world, then these are all you need to do. The default <code>PlayerModule</code> instance already handles how Server Authority will be used internally, so you generally don't need to do anything.</p> <p>However, if you have systems dependant on how these characters and parts will behave on your world, or simply wish to understand and work with the system, then you may continue reading.</p>"},{"location":"main/howto/#runservice","title":"RunService","text":"<p>To begin working with Server Authority, there are a few new methods in <code>RunService</code> you need to utilize.</p>"},{"location":"main/howto/#methods","title":"Methods","text":""},{"location":"main/howto/#runservicebindtosimulationfunction-deltatime-number-frequency-enumstepfrequency","title":"<code>RunService:BindToSimulation(function: (deltaTime: number) -&gt; (), frequency: Enum.StepFrequency?)</code>","text":"<p>This method allows you to bind a function to the simulation with a certain amount of frequency. Depending on the frequency, this function will be called with a <code>deltaTime</code> argument. If a frequency argument has not been provided, then it will default to <code>Enum.StepFrequency.Hz60</code>. This is the right place to put your core game logic, including processing input and updating your synchronized game data.</p>"},{"location":"main/howto/#runservicesetpredictionmodecontext-instance-mode-enumpredictionmode","title":"<code>RunService:SetPredictionMode(context: Instance, mode: Enum.PredictionMode)</code>","text":"<p>Determines whether the engine will rollback and resimulate the context <code>Instance</code>.</p> <ul> <li> <p>If <code>mode</code> is <code>Enum.PredictionMode.Off</code>: Disables rollback and resimulation for the Instance. When a place's <code>Workspace.AuthorityMode</code> is set to <code>Server</code>, the <code>Instance</code> will be owned by the server with no client-side prediction.</p> </li> <li> <p>If <code>mode</code> is <code>Enum.PredictionMode.Automatic</code> (default value): Allows the engine to determine whether to rollback and resimulate the <code>Instance</code>. For <code>Instance</code>s that derive from <code>BasePart</code>, the engine uses the player\u2019s simulation radius to determine if an <code>Instance</code> should be predicted. This helps limit expensive client-side prediction to only the relevant <code>Instance</code>s. At the moment, Non-<code>BasePart</code>s will not rollback when set to <code>Automatic</code>.</p> </li> <li> <p>If <code>mode</code> is <code>Enum.PredictionMode.On</code>: Will ensure the <code>Instance</code> is always rolled back when a misprediction occurs. For <code>Instance</code>s critical to your experience, use this setting. Otherwise, do not overuse <code>On</code> for <code>Instance</code>s, as it\u2019ll have significant performance implications for low-end devices.</p> </li> </ul>"},{"location":"main/howto/#runservicegetpredictionstatuscontext-instance-enumpredictionstatus","title":"<code>RunService:GetPredictionStatus(context: Instance): Enum.PredictionStatus</code>","text":"<p>This function allows you to check the prediction status of the context <code>Instance</code>. This may be essential for scripts affecting multiple instances (e.g., vehicle controllers, custom physics) where some might be predicted and other might not. It may also be useful for debugging and observing the effects of automatic prediction.</p>"},{"location":"main/howto/#obtaining-the-current-frame","title":"Obtaining the Current Frame","text":"<p>When Server Authority is enabled, the global <code>time()</code> function becomes synchronized with the rollback netcode model. Calling this function will return a value that determines the current frame number of the world. It is also rolled back on the client when a misprediction occurs. Printing this number can be helpful for debugging your systems.</p>"},{"location":"main/howto/#attributes","title":"Attributes","text":"<p>Attributes on predicted <code>Instance</code>s are fully synchronized with the rollback netcode model. This means that on the client, attributes are compared against the Server's version and mismatches will cause a full rollback and resimulation. You can use this to store game data that affects your core simulation and gameplay, e.g., scores, health, ammunition, etc.</p> <p>Note</p> <p>For Non-BasePart <code>Instance</code>s, you must set the <code>Instance</code>'s <code>PredictionMode</code> to <code>Enum.PredictionMode.On</code> to have it be fully synchronized. </p> <p>Although attributes are fully synchronized with the rollback netcode model, to ensure efficient data synchronization and the best gameplay experience, Roblox has imposed certain limits on the number and size of attributes that can be set per <code>Instance</code> on the Server. Attempting to exceed these limits will result in an error. While you can still set attributes in the Studio UI, any that violate these limits will not be loaded.</p> <p>Attribute Limits Per Instance (Server-side):</p> <ul> <li>Maximum of 64 Entries.</li> <li>Names and string values must be &lt; 50 characters long.</li> <li>Maximum of 1KB total data size.</li> </ul>"},{"location":"main/howto/#debugging-and-tooling","title":"Debugging and Tooling","text":"<p>Press CTRL + SHIFT + F6 on Windows or CMD + SHIFT + F6 on macOS to enable the Server Authority Visualizer. When it\u2019s on, you\u2019ll see a new debug pane appear at the bottom-right of your viewport. Along with showing statistics about Server Authority, this tool shows PV mispredictions for all predicted <code>Instance</code>s in the workspace. Pairs of boxes connected by pink lines show mispredictions: for each pair, the blue box represents the client\u2019s misprediction and the green box represents the server\u2019s authoritative simulation. Each box emits a vector representing the <code>CFrame</code>'s facing direction at the given location. You can clear the mispredictions from the world with CTRL/CMD + SHIFT + F7 and sort them by proximity to the player with CTRL/CMD + SHIFT + F8.</p>"},{"location":"main/howto/#implementing-systems-with-server-authority","title":"Implementing Systems with Server Authority","text":"<p>Server Authority requires you to run the same simulation code on both the Server and the Client. This is necessary for accuracy.</p> <p>We can implement this simulation code in many ways, however, to make it easier and more efficient to implement such a system, a multi-script architecture will be used for implementation in this documentation.</p> <p>We will use this architecture to initialize the same system on both the Server and the Client. To do this, you can create a <code>ModuleScript</code> which is parented to a location that is accessible from both the Server and the Client, such as <code>ReplicatedStorage</code>. Then, by creating a <code>Script</code> for both the Server and Client contexts, we can initialize and run this shared <code>ModuleScript</code> on each context.</p> <p>An example:</p> <p></p> <p>We have two scripts which initialize the \"SimulationModule\" <code>ModuleScript</code> on both the Server and the Client.</p>"},{"location":"main/howto/#simulationclient-and-simulationserver","title":"SimulationClient and SimulationServer","text":"<pre><code>require(script.Parent.SimulationModule).Run()\n</code></pre>"},{"location":"main/howto/#simulationmodule","title":"SimulationModule","text":"<pre><code>local module = {}\n\nfunction module.Run()\n    -- This code will be ran on both the server and the client.\nend\n\nreturn module\n</code></pre> <p>This simple architecture will be the foundation of our many systems that will run on the server-authoritative model. Using this, we can implement many types of systems, such as a character movement system, which can be found in the Examples section.</p>"}]}