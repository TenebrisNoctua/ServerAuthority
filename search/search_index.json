{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":"<p>Hello. This is a detailed documentation about the new server authority system that Roblox has showcased recently. It is a new system aiming to achieve a better physics simulation, while also providing better security. This documentation will try to give you almost all of the available information about this new system. However, not all information may be accurate, as this system is still a work-in-progress.</p> <p>With all that being said, this documentation may recieve updates whenever there's a new feature added, or a feature removed. If you want to stay up-to-date, make sure to visit this documentation again later, and if you have any additional information that you can provide about this system, let me know with a message on my Twitter.</p> <p>Let's begin.</p>"},{"location":"#how-to-access","title":"How to Access?","text":"<p>If you want to access everything that will be mentioned in later sections, you must either:</p> <p>(A) Enroll in the Early Access Program for the Server Authority Core API. (B) Enable certain flags in Roblox Studio.*</p> *: This documentation will not mention on how you can edit flags in Roblox Studio, as it is not my responsibility."},{"location":"#enrolling-to-the-early-access-program-for-the-server-authority-core-api","title":"Enrolling to the Early Access Program for the Server Authority Core API","text":"<p>This is the simplest way you can gain access to the new features that will be mentioned in this documentation. You can send a reply to this thread to apply for the program. </p> <p>If you're accepted, go to your account settings, and scroll down to the \"Early Access Programs\" section. Then, select the \"Early Access: Server Authority Core API Early Access\" program. This will now enroll you to the program, and following the steps below, you can access the features.</p>"},{"location":"#if-using-vanilla-studio","title":"If using vanilla Studio","text":"<p>Restart your Studio. Upon the restart, there will be an \"Update Studio\" button on the top right. Clicking this button will automatically update your Studio and install the version meant for the program. After this, you should be good to go.</p>"},{"location":"#if-using-a-custom-bootstrapper","title":"If using a custom bootstrapper","text":"<p>If your custom bootstrapper application to launch Studio does not have a built-in system for automatically opening the version meant for the early access program, then follow the steps below.</p> <p>Go to your creator page. And re-download the Studio application. After install, it should automatically open. Click on the \"Update Studio\" button on the top right. This will automatically update your Studio and install the version meant for the program. After this, you should be good to go.</p> <p>Do not forget to launch the Studio application through the versions folder for the Studio application. Using your custom bootstrapper may not work.</p>"},{"location":"#enabling-certain-flags-in-roblox-studio","title":"Enabling certain flags in Roblox Studio","text":"<p>If you're not enrolled in the early access program, you can set the flags below to <code>True</code> to access the features.</p> <pre><code>DebugAuroraDefaultConfig\nDebugHashTableMetrics\nNextGenReplicatorEnabledRead3\nNextGenReplicatorEnabledWrite4\nDebugEnableAuroraService\nStudioAuroraEditorSupport\n</code></pre> <p>Warning</p> <p>Modifying Roblox Studio flags is not recommended, as it can corrupt your places, or even the Studio app itself. I heavily recommend you to try to gain access through the early access program instead. Regardless, I will not accept any responsibility that comes from you modifying your Studio application.</p>"},{"location":"#server-authority","title":"Server Authority","text":"<p>To give a short summary on what Server Authority is, it is when the server becomes the single source of truth for game actions, logic, and data. This basically means that the server will dictate how the data and logic such as physics will work within your game.</p> <p>To fully enable this feature in Roblox Studio, you must go into the <code>Workspace</code> properties and change some values. They are listed below:</p> <ul> <li><code>Server Authority &gt; AuthorityMode</code>: <code>Server</code></li> <li><code>Behavior &gt; PhysicsSteppingMethod</code>: <code>Fixed</code></li> </ul> <p>Warning</p> <p>Setting the <code>AuthorityMode</code> to <code>Server</code> will automatically change certain other workspace properties. They are listed below:</p> <ul> <li><code>StreamingEnabled</code>: <code>true</code></li> <li><code>SignalBehavior</code>: <code>Deferred</code></li> </ul> <p>These properties cannot be changed while the <code>AuthorityMode</code> is set to <code>Server</code>.</p>"},{"location":"#part-physics","title":"Part Physics","text":"<p>Enabling this feature completely changes the behavior of all unanchored <code>Part</code>s in the <code>Workspace</code>. Before; the physics calculation of a <code>Part</code> was handled by both the server and the clients in a place. When a client came close to a <code>Part</code>, the network ownership would automatically shift from the server to the client, so the client could take the burden of calculating the physics for that <code>Part</code>.</p> <p>However, now, with server authority enabled; this network ownership behavior is disabled by default. The server and the client now calculates the physics for the said part at the same time, while the server being the source of truth.</p>"},{"location":"#character-physics","title":"Character Physics","text":"<p>Before, because of network ownership, the client had full control over their character. This allowed them to change certain properties of their character such as velocity, position, rotation, and many others to their liking. This of course, caused many security issues. Using exploits, the client would be able to give themselves an unfair advantage in gameplay by changing these properties. This gave the rise of many exploiting issues such as speed-hacking, fly-hacking, no-clipping, teleporting, and many others inside popular places on the platform.</p> <p>The issues are not only limited to exploiting. In many competitive games, such as racing, the cars would most of the time be misaligned, or their position would constantly jitter, or look very different. That is because of client calculated physics of the previous system. Because the network ownership of each car is set to each client, rather than the server, the car positions would end up different than expected.</p> <p>With the new server authority system, most of these issues, if not all of them, are automatically resolved.</p> <p>An example from the first case, where a client would modify their character to gain an unfair advantage such as speedhacking, would no longer be possible, as the client no longer holds ownership of their character, and all that is given to the server are inputs.</p> <p>For the second case, since the server now calculates the positions of the cars, they now move more consistently. Maneuvers, drifts, hits, become more accurate on each client, and the system works more reliably.</p> <p>If you want to see this system in action, you can easily do some tests yourself. Hitting \"Test\", should give you the chance to test pretty much anything you want.</p> <p>A good way to test the new system would be to create a wall infront of the character on the server, and then delete it on the client. Then, you can try to pass through the place where the wall was prior to deletion. You will quickly notice that you're unable to move past the place where the wall once was, like the wall is still there, but invisible.</p>"},{"location":"#the-prediction-system","title":"The Prediction System","text":"<p>Warning</p> <p>Information in this section may be inaccurate in certain places, if you have any valid corrections, please don't hesitate to reach out to me. </p> <p>The server authority system is powered by a netcode system with predictions and rollback. Under this system, all characters and parts have their network ownership set to the server. By default, the server calculates the physics or movement of all of the parts and characters, and the only thing client sends to the server are the inputs for the movement. Normally, a system like this would result in choppy physics and movement, and it wouldn't feel responsive. This was the main issue with implementing a server authoritative system. However, to solve this issue, a prediction system was implemented.</p> <p>On the client, the character is simulated just like it's on the server. However, for the character movement to feel responsive and smooth, it is simulated a little bit ahead of the server. This is called \"prediction\". The client \"predicts\" where the character might be in the next second ahead of the server, to make sure the experience feels a lot smoother and responsive, while the server dictates where the character actually will be. However, if the client and server disagrees on where the character will be (a misprediction), then a rollback occurs. This rollback allows the client to resimulate the physics and the state of the character, and to catch up where it is supposed to be.</p> <p>Mispredictions are normal and expected. They should be small and the resulting correction should be imperceptible to clients.</p> <p></p> <p>Example</p> <p>Your client thinks you\u2019ve moved forward. However, the server registered that you were hit by a stun grenade and can\u2019t move for a few  seconds. The client and server now have different states.</p> <p>This divergence is called a misprediction. It can occur for several reasons: the network latency has shifted, other players acted in ways the client didn\u2019t anticipate, the experience runs certain logic exclusively on the Server, etc. While you can\u2019t prevent every misprediction, you can keep gameplay feeling smooth and responsive by using the right techniques.</p> <p>Basically, the client can be slightly incorrect and make a \"misprediction.\" Things like latency variance and other players inputs can cause the client to be slightly incorrect.</p> <p>After misprediction, the client rolls back to the authoritative update by reverting its current state and time. Then, the client resimulates automatically after rollback to speed back to its predicted frame. The number of frames to resimulate is based on the latency between the client and the server. The client tries to stay far enough ahead of the server so that its own inputs arrive on the server just in time to be processed on the frame the user intended to perform them.</p> <p>Example</p> <p>Let\u2019s say there is 100ms of latency between the client and server, and the experience is a 60Hz game.</p> <p>Each frame is 1/60s (or 16.67ms). Since 100ms of latency is equivalent to ~6 frames (100 ms divided by 16.67 ms/frame), we know the client will be 6 frames ahead of the server. This means that, when the client detects it made a misprediction, it will rollback to the server's state and then resimulate frames ahead. In general, the player should hardly notice this.</p>"},{"location":"#the-input-action-system","title":"The Input Action System","text":"<p>The Input Action System (IAS) is a major part of the server authority system. It allows you to reliably transfer inputs from client to the server, while allowing you to customize them easily. I will not be explaining this system and how it works however. You can check out the main post talking about it through here.</p> <p>Player inputs like joystick movement and button presses are sent from client to server using <code>InputAction</code>s. You have to use <code>InputAction</code> for all inputs that affect the core game simulation, because they are the only client authoritative data in the core rollback system.</p> <p>You can send any continuous stream of data from the client to server using this API, and the server will trust what the client has sent. It is up to you to validate that the clients have sent legitimate inputs. Be sure to enforce maximum and minimum ranges on numbers sent from the client, just like how you would validate values sent from remotes.</p> <p>Note</p> <p>The server will automatically ignore input data from the client if it arrives far too late or far too early, which can happen if there are sudden changes in a client's network conditions.</p>"},{"location":"#runservice","title":"RunService","text":"<p>There are new properties and events added to <code>RunService</code> which you can utilize to work with the server authority system.</p>"},{"location":"#properties","title":"Properties","text":""},{"location":"#runserviceframenumber","title":"<code>RunService.FrameNumber</code>","text":"<p>This value determines the current frame number. This value is rolled back on the client when a resimulation occurs. It is the foundation upon which features like <code>FixedHeartbeat</code> are built. Printing this number can be helpful for understanding what exactly is happening when on the client and server.</p>"},{"location":"#runservicepredictionstate","title":"<code>RunService.PredictionState</code>","text":"<p>This property allows you to see the current state of the simulation. It can have one of the following values:</p> <ul> <li><code>Enum.PredictionState.Idle</code>: The default state outside of the simulation loop.</li> <li><code>Enum.PredictionState.Simulating</code>: Physics is stepping forward normally.</li> <li><code>Enum.PredictionState.RollingBack</code>: A misprediction has been detected, and the last known server values are being applied to the predicted instances.</li> <li><code>Enum.PredictionState.Resimulating</code>: The engine is rolling forward after a misprediction.</li> </ul>"},{"location":"#events","title":"Events","text":""},{"location":"#runservicefixedheartbeatdeltatime-number","title":"<code>RunService.FixedHeartbeat(deltaTime: number)</code>","text":"<p>This signal is fired just like the normal <code>Heartbeat</code> signal, but is also fired again for each frame of resimulation after a misprediction is detected. This is the right place to put your core game logic, including processing input and updating your synchronized game data.</p>"},{"location":"#runservicemispredictionremoteworldstepid-number-mispredictedinstances-any","title":"<code>RunService.Misprediction(remoteWorldStepId: number, mispredictedInstances: {any})</code>","text":"<p>This signal is fired when a misprediction occurs on the client. This means the client has received data from the server that did not match what it had previously simulated. The client is about to go back to the server state and call <code>FixedHeartbeat</code> to bring itself back up to its present frame. The second argument contains information about which properties on which <code>Instance</code>s were incorrect, and how many frames will be simulated. In general, if playing by yourself, you should only see a small number of mispredictions when your ping to the server changes.</p>"},{"location":"#instance","title":"Instance","text":"<p>Alongside <code>RunService</code>, there are new methods implemented to control the prediction state for <code>Instance</code>s.</p>"},{"location":"#methods","title":"Methods","text":""},{"location":"#instancesetpredictionmodemode-enumpredictionmode","title":"<code>Instance:SetPredictionMode(mode: Enum.PredictionMode)</code>","text":"<p>Determines whether the engine will rollback and resimulate the <code>Instance</code>.</p> <ul> <li> <p>If <code>mode</code> is <code>Enum.PredictionMode.Off</code>: Disables rollback and resimulation for the Instance. When a place's <code>Workspace.AuthorityMode</code> is set to <code>Server</code>, the <code>Instance</code> will be owned by the server with no client-side prediction.</p> </li> <li> <p>If <code>mode</code> is <code>Enum.PredictionMode.Automatic</code> (default value): Allows the engine to determine whether to rollback and resimulate the <code>Instance</code>. For <code>Instance</code>s that derive from <code>BasePart</code>, the engine uses the player\u2019s simulation radius to determine if an <code>Instance</code> should be predicted. This helps limit expensive client-side prediction to only the relevant <code>Instance</code>s. At the moment, Non-<code>BasePart</code>s will not rollback when set to <code>Automatic</code>.</p> </li> <li> <p>If <code>mode</code> is <code>Enum.PredictionMode.On</code>: Will ensure the <code>Instance</code> is always rolled back when a misprediction occurs. For <code>Instance</code>s critical to your experience, use this setting. Otherwise, do not overuse <code>On</code> for <code>Instance</code>s, as it\u2019ll have significant performance implications for low-end devices.</p> </li> </ul>"},{"location":"#instancegetpredictionmode-enumpredictionmode","title":"<code>Instance:GetPredictionMode(): Enum.PredictionMode</code>","text":"<p>Returns the prediction mode enum that indicates whether the engine will rollback and resimulate the <code>Instance</code>.</p>"},{"location":"#instanceispredicted-boolean","title":"<code>Instance:IsPredicted(): boolean</code>","text":"<p>Returns a boolean indicating whether the <code>Instance</code> is being predicted or not.</p>"},{"location":"#attribute-rollback","title":"Attribute Rollback","text":"<p>Attributes on predicted <code>Instance</code>s are fully synchronized with the rollback netcode model. For Non-<code>BasePart</code> <code>Instance</code>s, you must set the <code>Instance</code>'s <code>PredictionMode</code> to <code>Enum.PredictionMode.On</code> to have it be fully synchronized. This means that on the client, attributes are compared against the server\u2019s version and mismatches will cause a full rollback and resimulation. You should use attributes to store the game data that affect your core simulation. Examples include scores, health, ammunition, inventory, or custom game rules (like which player last touched a ball).</p>"},{"location":"#debugging-and-tooling","title":"Debugging and Tooling","text":"<p>Press CTRL + SHIFT + F6 on Windows or CMD + SHIFT + F6 on macOS to enable the Server Authority Visualizer. When it\u2019s on, you\u2019ll see a new debug pane appear at the bottom-right of your viewport. Along with showing statistics about server authority, this tool shows PV mispredictions for all predicted <code>Instance</code>s in the workspace. Pairs of boxes connected by pink lines show mispredictions: for each pair, the blue box represents the client\u2019s misprediction and the green box represents the server\u2019s authoritative simulation. Each box emits a vector representing the <code>CFrame</code>'s facing direction at the given location. You can clear the mispredictions from the world with CTRL/CMD + SHIFT + F7 and sort them by proximity to the player with CTRL/CMD + SHIFT + F8.</p>"},{"location":"examples/","title":"Examples","text":"<p>Welcome to the Examples section! In this section, you can find examples of systems you can implement with Server Authority. On the left side, there are pages which contain tutorials and snippets of code which may help you to learn how to do various small or large scale systems with Server Authority.</p> <p>Note</p> <ul> <li> <p>Every script must be parented under the \"ServerAuthority\" folder in <code>ReplicatedStorage</code>. (Create one if it doesn't exist)</p> </li> <li> <p>Each example contains two ways to achieve the same system. </p> </li> </ul>"},{"location":"examples/#open-source-projects-from-roblox","title":"Open-Source Projects from Roblox","text":"<p>Besides example pages, there are certain open-source projects created by Roblox with Server Authority. You can also check them out!</p>"},{"location":"examples/#the-soccer-game","title":"The Soccer Game","text":"<p>In this game, you play soccer while rolling around in a ball, playing against the opposite team.</p> <p>Play and edit the game on Roblox here.</p>"},{"location":"examples/character/","title":"Character Movement System","text":"<p>This is an example character movement system that you can create with Server Authority.</p>"},{"location":"examples/character/#the-design","title":"The Design","text":"<p>In a server-authoritative model, the same code must run on both the Server and the Client. This is how the client predicts what the server will do. To achieve this, we have two options: We can use <code>ModuleScript</code>s to do it in a modular way, or we can use the new <code>AuroraScript</code> object to do it all in one script architecture.</p>"},{"location":"examples/character/#default-modular-way","title":"Default (Modular) Way","text":"<p>First, under the \"ServerAuthority\" folder in <code>ReplicatedStorage</code>, we create a <code>ModuleScript</code> named \"CharacterMovement\". This will be our main module which will contain the movement system. It will be used both by the server and the client.</p> <p>The hierarchy should look like this:</p> <p></p> <p>Then, in this module, we connect to the <code>RunService.FixedHeartbeat(deltaTime: number)</code> signal with a callback function.</p>"},{"location":"examples/character/#charactermovement","title":"CharacterMovement","text":"<pre><code>local RunService = game:GetService(\"RunService\")\n\nlocal MovementModule = {\n    Connections = {} :: {RBXScriptConnection}\n}\n\n -- This function begins the movement calculation for a player.\nfunction MovementModule.BeginMovement(player: Player)\n    -- We connect to the .FixedHeartbeat event of RunService, and add the Connection object to the Connections table to track it.\n    MovementModule.Connections[player] = RunService.FixedHeartbeat:Connect(function(deltaTime: number)\n        -- This will be the function to start calculating the movement of a player's character in.\n    end)\nend\n\n-- This function stops the movement calculation for a player.\nfunction MovementModule.EndMovement(player: Player) \n    local FoundConnection: RBXScriptConnection? = MovementModule.Connections[player]\n    if not FoundConnection then return end\n\n    FoundConnection:Disconnect()\n    MovementModule.Connections[player] = nil\nend\n\nreturn MovementModule\n</code></pre> <p>We now have a simple initial system that allows us to connect to the <code>.FixedHeartbeat</code> signal. Before we continue to write the actual calculation system however, we need to create some new <code>Instance</code>s to get the input from the player.</p> <p>To do this, we create another folder called \"Input\" and create an <code>InputContext</code> with certain <code>InputAction</code>s parented to it, allowing us to get movement input from the player's client.</p> <p>We will create 4 <code>InputAction</code>s under this <code>InputContext</code>, called: \"Camera\", \"Jump\", \"Move\", \"Rotation\". To support both gamepad and keyboard input, we create two <code>InputBinding</code>s under the \"Jump\" and \"Move\" <code>InputAction</code>s.</p> <p>For the \"Jump\" <code>InputAction</code> (<code>Bool</code> Type), we will add the <code>Space</code> KeyCode to first <code>InputBinding</code>, called \"KeyboardBinding\". And for the next one, which we can call \"GamepadBinding\", we add the <code>ButtonA</code> KeyCode.</p> <p>For the \"Move\" <code>InputAction</code> (<code>Direction2D</code> Type), we will add 4 directions to the first <code>InputBinding</code> meant for keyboard, called \"KeyboardBinding\":</p> <ul> <li>Down: <code>S</code></li> <li>Up: <code>W</code></li> <li>Left: <code>A</code></li> <li>Right: <code>D</code></li> </ul> <p>For the next <code>InputBinding</code>, called \"GamepadBinding\", we will set the KeyCode to <code>Thumbstick 1</code>.</p> <p>The hierarchy should now look like this:</p> <p></p> <p>We will be cloning this input system to the player object with a script later.</p> <p>We can now move on to creating the actual system which will calculate the movement for the character.</p>"},{"location":"examples/character/#charactermovement_1","title":"CharacterMovement","text":"<pre><code>local RunService = game:GetService(\"RunService\")\n\nlocal MovementModule = {\n    Connections = {} :: {RBXScriptConnection}\n}\n\n -- This is the function that begins the movement calculation for a player.\nfunction MovementModule.BeginMovement(player: Player)\n    -- We connect to the .FixedHeartbeat event of RunService, and add the Connection object to the Connections table to track it.\n    MovementModule.Connections[player] = RunService.FixedHeartbeat:Connect(function(deltaTime: number)\n        if not player.Character then player.CharacterAdded:Wait() end -- Waiting until there's a valid character model.\n\n        local Character = player.Character\n        local Humanoid: Humanoid = Character.Humanoid \n        local Input: InputContext = player.Input.Default\n\n        local MoveInput: InputAction = Input.Move\n        local CameraInput: InputAction = Input.Camera\n        local RotationInput: InputAction = Input.Rotation\n        local JumpInput: InputAction = Input.Jump\n\n        -- Getting the values from InputActions. We use :GetState() here instead of .StateChanged.\n        local MoveVector2D: Vector2 = MoveInput:GetState() \n        local CameraVector2D: Vector2 = CameraInput:GetState()\n        local RotationIsCameraRelative: boolean = RotationInput:GetState()\n        local JumpBoolean: boolean = JumpInput:GetState()\n\n        -- Calculating the move direction based on camera and movement input.\n        local CameraVector3D = Vector3.new(CameraVector2D.X, 0, CameraVector2D.Y)\n        local RightVector = CameraVector3D:Cross(Vector3.yAxis)\n\n        local MoveVector = CameraVector3D * MoveVector2D.Y + RightVector * MoveVector2D.X\n        local MoveDirection = Vector3.new(MoveVector.X, 0, MoveVector.Z)\n\n        -- Moving the Humanoid to the target move direction.\n        Humanoid:Move(MoveDirection)\n\n        -- Rotating the Character based on camera direction.\n        if RotationIsCameraRelative then\n            Humanoid.AutoRotate = false\n            if not Humanoid.SeatPart and Humanoid.RootPart then\n                Humanoid.RootPart.CFrame = CFrame.new(Humanoid.RootPart.CFrame.Position, Humanoid.RootPart.CFrame.Position + CameraVector3D)\n            end\n        else\n            Humanoid.AutoRotate = true\n        end\n\n        -- Allowing the Character to jump based on input, and if it's not currently in-air.\n        local currentState = Humanoid:GetState()\n        local isInAir = currentState == Enum.HumanoidStateType.FallingDown\n            or currentState == Enum.HumanoidStateType.Freefall\n            or currentState == Enum.HumanoidStateType.Jumping\n\n        if not isInAir and JumpBoolean then\n            Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)\n        end\n    end)\nend\n\n-- This function stops the movement calculation for a player.\nfunction MovementModule.EndMovement(player: Player) \n    local FoundConnection: RBXScriptConnection? = MovementModule.Connections[player]\n    if not FoundConnection then return end\n\n    FoundConnection:Disconnect()\n    MovementModule.Connections[player] = nil\nend\n\nreturn MovementModule\n</code></pre> <p>Our system is almost ready! Now, for the system to start working, we need to initialize and run this module from both the server and the client. And we also need to clone and parent the \"Input\" folder we created above to the player, so the system can start capturing input from the client.</p>"},{"location":"examples/character/#serversetup","title":"ServerSetup","text":"<pre><code>local Players = game:GetService(\"Players\")\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal ServerAuthority = ReplicatedStorage.ServerAuthority\nlocal Modules = ServerAuthority.Modules\nlocal Input = ServerAuthority.Input\n\nlocal CharacterMovement = require(Modules.CharacterMovement)\n\n-- This function sets the streaming mode for the character model to Atomic upon character load.\nlocal function InitializeCharacter(character: Model)\n    character.ModelStreamingMode = Enum.ModelStreamingMode.Atomic\nend\n\n-- This function clones and parents the Input folder to the player to start capturing input, and begins the movement calculation.\nlocal function InitializePlayer(player: Player)\n    if player.Character then InitializeCharacter(player.Character) end\n    player.CharacterAdded:Connect(InitializeCharacter)\n\n    local InputTemplate = Input:Clone()\n    InputTemplate.Parent = player\n\n    CharacterMovement.BeginMovement(player)\nend\n\n-- This function initializes the above functions for all existing players, or new players.\nlocal function Initialize()\n    for _, player in Players:GetPlayers() do\n        InitializePlayer(player)\n    end\n    Players.PlayerAdded:Connect(InitializePlayer)\nend\n\n-- We want to only run the above systems when the AuthorityMode is set to Server. Automatic results in inconsistent behavior.\nif workspace.AuthorityMode == Enum.AuthorityMode.Server then\n    Initialize()\nend\n</code></pre> <p>This is our server script that initializes the movement calculation and input parenting for a player. This is our main system that allows the player to move.</p>"},{"location":"examples/character/#clientsetup","title":"ClientSetup","text":"<pre><code>local Players = game:GetService(\"Players\")\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal ServerAuthority = ReplicatedStorage.ServerAuthority\nlocal Modules = ServerAuthority.Modules\n\nlocal CharacterMovement = require(Modules.CharacterMovement)\nlocal LocalPlayer = Players.LocalPlayer\n\n-- This function begins the client prediction for the character.\nlocal function InitializeCharacter(character: Model)\n    local HumanoidRootPart: Part = character:WaitForChild(\"HumanoidRootPart\")\n    HumanoidRootPart:SetPredictionMode(Enum.PredictionMode.On)\nend\n\n-- This function initializes the movement prediction and the character.\nlocal function Initialize()\n    if LocalPlayer.Character then InitializeCharacter(LocalPlayer.Character) end\n    LocalPlayer.CharacterAdded:Connect(InitializeCharacter)\n\n    CharacterMovement.BeginMovement(LocalPlayer)\nend\n\n-- We want to only run the above systems when the AuthorityMode is set to Server. Automatic results in inconsistent behavior.\nif workspace.AuthorityMode == Enum.AuthorityMode.Server then\n    Initialize()\nend\n</code></pre> <p>This is our client script that initializes the movement prediction for a player. This is our main system that allows a smooth experience for the player movement.</p> <p>However, we also need to create another client script to capture input for the camera:</p>"},{"location":"examples/character/#camerainput","title":"CameraInput","text":"<pre><code>local Players = game:GetService(\"Players\")\nlocal RunService = game:GetService(\"RunService\")\nlocal UserGameSetting = UserSettings():GetService(\"UserGameSettings\")\n\nlocal LocalPlayer = Players.LocalPlayer\n\n-- Defining the InputActions for the camera and rotation.\nlocal Input = LocalPlayer:WaitForChild(\"Input\")\nlocal CameraInput: InputAction = Input.Default.Camera\nlocal RotationInput: InputAction = Input.Default.Rotation\n\nif workspace.AuthorityMode == Enum.AuthorityMode.Server then\n    -- This callback function calculates the current rotation of the character and the camera, and sends it to the server.\n    RunService:BindToRenderStep(\"CameraInput\", Enum.RenderPriority.Last.Value, function()\n        local Camera = workspace.CurrentCamera\n        local YAxis: Vector3 = Vector3.yAxis\n        local Forward = YAxis:Cross(Camera.CFrame.RightVector)\n\n        CameraInput:Fire(Vector2.new(Forward.X, Forward.Z))\n        RotationInput:Fire(UserGameSetting.RotationType == Enum.RotationType.CameraRelative)\n    end)\nend\n</code></pre> <p>After everything above has been complete, our new system hierarchy should now look like this:</p> <p></p> <p>And that's all! Hitting the \"Play\" button should allow you to test our new system. This new character system provides a secure and accurate character simulation, while behaving smoothly for the player's view.</p>"},{"location":"examples/character/#behavior-way","title":"Behavior Way","text":"<p>While the modular system works, it is not fully desirable as it requires us to create loaders from both the server and the client, and a module script which runs the movement system. To make make it more desirable and easier for us to create Server Authority systems, there exists a new <code>Instance</code> called <code>AuroraScript</code>. This new instance allows us to define a behavior which will both run on the server and the client.</p> <p>To learn more about Behaviors, check out the Services and Behaviors section.</p> <p>First we create a new <code>AuroraScript</code> called \"CharacterMovement\". This will be our main script which will contain the movement system.</p>"},{"location":"examples/character/#charactermovement_2","title":"CharacterMovement","text":"<pre><code>local RunService = game:GetService(\"RunService\")\nlocal Players = game:GetService(\"Players\")\n\ntype AuroraScriptObject = {\n    Instance: Instance,\n    Frame: number,\n    LODLevel: number,\n    Connect: (self: AuroraScriptObject, signal: RBXScriptSignal, functionName: string) -&gt; RBXScriptConnection,\n    Subscribe: (self: AuroraScriptObject, topic: string, functionName: string) -&gt; string,\n    Publish: (self: AuroraScriptObject, topic: string, ...any) -&gt; any,\n    SendMessage: (self: AuroraScriptObject, boundInstance: Instance, behaviorName: string, functionName: string, ...any) -&gt; ...any,\n    Delay: (self: AuroraScriptObject, amount: number, functionName: string) -&gt; string,\n    SetMaxFrequency: (self: AuroraScriptObject, frequency: number) -&gt; number,\n    [string]: any\n}\n\n-- This function runs when the Behavior starts.\nfunction Behavior.OnStart(self: AuroraScriptObject)\n    -- We connect to the .FixedHeartbeat event of RunService here to DefaultMovement function of the Behavior.\n    self:Connect(RunService.FixedHeartbeat, \"DefaultMovement\")\n    self.Player = Players:GetPlayerFromCharacter(self.Instance) -- We find the Player from the bound Character instance and set it as a value within our Behavior.\nend\n\nfunction Behavior.DefaultMovement(self: AuroraScriptObject, deltaTime: number)\n    -- This function runs when .FixedHeartbeat fires with the deltaTime argument.\nend\n\n-- We declare a field in our Behavior to store the Player instance.\nBehavior.DeclareField(\"Player\", {Type = \"instance\"})\n</code></pre> <p>We now have a simple initial system that allows us to connect to the <code>.FixedHeartbeat</code> signal and set our Player property.</p> <p>However, just like in the modular way, we need to create an input system to capture input from the client. Repeating the steps from Modular Way, we now have a hierarchy like this:</p> <p></p> <p>We can now move on to creating the actual system which will calculate the movement for the character.</p>"},{"location":"examples/character/#charactermovement_3","title":"CharacterMovement","text":"<pre><code>local RunService = game:GetService(\"RunService\")\nlocal Players = game:GetService(\"Players\")\n\ntype AuroraScriptObject = {\n    Instance: Instance,\n    Frame: number,\n    LODLevel: number,\n    Connect: (self: AuroraScriptObject, signal: RBXScriptSignal, functionName: string) -&gt; RBXScriptConnection,\n    Subscribe: (self: AuroraScriptObject, topic: string, functionName: string) -&gt; string,\n    Publish: (self: AuroraScriptObject, topic: string, ...any) -&gt; any,\n    SendMessage: (self: AuroraScriptObject, boundInstance: Instance, behaviorName: string, functionName: string, ...any) -&gt; ...any,\n    Delay: (self: AuroraScriptObject, amount: number, functionName: string) -&gt; string,\n    SetMaxFrequency: (self: AuroraScriptObject, frequency: number) -&gt; number,\n    [string]: any\n}\n\n-- This function runs when the Behavior starts.\nfunction Behavior.OnStart(self: AuroraScriptObject)\n    -- We connect to the .FixedHeartbeat event of RunService here to DefaultMovement function of the Behavior.\n    self:Connect(RunService.FixedHeartbeat, \"DefaultMovement\")\n    self.Player = Players:GetPlayerFromCharacter(self.Instance) -- We find the Player from the bound Character instance and set it as a value within our Behavior.\nend\n\nfunction Behavior.DefaultMovement(self: AuroraScriptObject, deltaTime: number)\n    -- This function runs when .FixedHeartbeat fires with the deltaTime argument.\n\n    local Character: Model = self.Instance\n    local Player: Player = self.Player\n    if not Player then return end\n\n    local Humanoid: Humanoid = Character:WaitForChild(\"Humanoid\")\n\n    local Input: InputContext = Player.Input.Default\n\n    local MoveInput: InputAction = Input.Move\n    local CameraInput: InputAction = Input.Camera\n    local RotationInput: InputAction = Input.Rotation\n    local JumpInput: InputAction = Input.Jump\n\n    -- Getting the values from InputActions. We use :GetState() here instead of .StateChanged.\n    local MoveVector2D: Vector2 = MoveInput:GetState() \n    local CameraVector2D: Vector2 = CameraInput:GetState()\n    local RotationIsCameraRelative: boolean = RotationInput:GetState()\n    local JumpBoolean: boolean = JumpInput:GetState()\n\n    -- Calculating the move direction based on camera and movement input.\n    local CameraVector3D = Vector3.new(CameraVector2D.X, 0, CameraVector2D.Y)\n    local RightVector = CameraVector3D:Cross(Vector3.yAxis)\n\n    local MoveVector = CameraVector3D * MoveVector2D.Y + RightVector * MoveVector2D.X\n    local MoveDirection = Vector3.new(MoveVector.X, 0, MoveVector.Z)\n\n    -- Moving the Humanoid to the target move direction.\n    Humanoid:Move(MoveDirection)\n\n    -- Rotating the Character based on camera direction.\n    if RotationIsCameraRelative then\n        Humanoid.AutoRotate = false\n        if not Humanoid.SeatPart and Humanoid.RootPart then\n            Humanoid.RootPart.CFrame = CFrame.new(Humanoid.RootPart.CFrame.Position, Humanoid.RootPart.CFrame.Position + CameraVector3D)\n        end\n    else\n        Humanoid.AutoRotate = true\n    end\n\n    -- Allowing the Character to jump based on input, and if it's not currently in-air.\n    local currentState = Humanoid:GetState()\n    local isInAir = currentState == Enum.HumanoidStateType.FallingDown\n        or currentState == Enum.HumanoidStateType.Freefall\n        or currentState == Enum.HumanoidStateType.Jumping\n    if not isInAir and JumpBoolean then\n        Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)\n    end\nend\n\n-- We declare a field in our Behavior to store the Player instance.\nBehavior.DeclareField(\"Player\", {Type = \"instance\"})\n</code></pre> <p>Our behavior is now done! This behavior will now run when it has been bound to a player's character. To do this however, we need to manually bind it upon character load on the server. For this, we can add a <code>Script</code> called \"ServerSetup\".</p>"},{"location":"examples/character/#serversetup_1","title":"ServerSetup","text":"<pre><code>local Players = game:GetService(\"Players\")\nlocal ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\n\nlocal ServerAuthority = ReplicatedStorage.ServerAuthority\nlocal Scripts = ServerAuthority.Scripts\nlocal Input = ServerAuthority.Input\n\n-- This function sets the streaming mode for the character model to Atomic, and binds the character to the behavior upon load.\nlocal function InitializeCharacter(character: Model)\n    character.ModelStreamingMode = Enum.ModelStreamingMode.Atomic\n    Scripts.Behavior:AddTo(character)\nend\n\n-- This function clones and parents the Input folder to the player to start capturing input.\nlocal function InitializePlayer(player: Player)\n    if player.Character then InitializeCharacter(player.Character) end\n    player.CharacterAdded:Connect(InitializeCharacter)\n\n    local InputTemplate = Input:Clone()\n    InputTemplate.Parent = player\nend\n\n-- This function initializes the above functions for all existing players, or new players.\nlocal function Initialize()\n    for _, player in Players:GetPlayers() do\n        InitializePlayer(player)\n    end\n    Players.PlayerAdded:Connect(InitializePlayer)\nend\n\n-- We want to only run the above systems when the AuthorityMode is set to Server. Automatic results in inconsistent behavior.\nif workspace.AuthorityMode == Enum.AuthorityMode.Server then\n    Initialize()\nend\n</code></pre> <p>This is our server script that parents the Input folder to a player, and binds the behavior to its character when it loads.</p> <p>With this system, the character can now move, however, we still need to create a client <code>Script</code> to capture input for the camera:</p>"},{"location":"examples/character/#camerainput_1","title":"CameraInput","text":"<pre><code>local Players = game:GetService(\"Players\")\nlocal RunService = game:GetService(\"RunService\")\nlocal UserGameSetting = UserSettings():GetService(\"UserGameSettings\")\n\nlocal LocalPlayer = Players.LocalPlayer\n\n-- Defining the InputActions for the camera and rotation.\nlocal Input = LocalPlayer:WaitForChild(\"Input\")\nlocal CameraInput: InputAction = Input.Default.Camera\nlocal RotationInput: InputAction = Input.Default.Rotation\n\nif workspace.AuthorityMode == Enum.AuthorityMode.Server then\n    -- This callback function calculates the current rotation of the character and the camera, and sends it to the server.\n    RunService:BindToRenderStep(\"CameraInput\", Enum.RenderPriority.Last.Value, function()\n        local Camera = workspace.CurrentCamera\n        local YAxis: Vector3 = Vector3.yAxis\n        local Forward = YAxis:Cross(Camera.CFrame.RightVector)\n\n        CameraInput:Fire(Vector2.new(Forward.X, Forward.Z))\n        RotationInput:Fire(UserGameSetting.RotationType == Enum.RotationType.CameraRelative)\n    end)\nend\n</code></pre> <p>After everything above has been complete, our new system hierarchy should now look like this:</p> <p></p> <p>And that's all! Hitting the \"Test\" button should allow you to test our new system. This new character system provides a secure and accurate character simulation, while behaving smoothly for the player's view.</p>"},{"location":"main/aurora/","title":"Services and Behaviors","text":"<p>Warning</p> <p>The services and <code>Instance</code>s mentioned in this page cannot be accessed without configuring certain flags. If you have enabled the flags from the previous page, you may continue. However, if you've just enrolled into the program without changing the flags, then it is not recommended for you to read this page.</p> <p>In the previous pages, I've explained the default behavior of the Server Authority system. While this behavior is mostly sufficient, there are cases where you might need more control. For example, what if you want to opt-out of the prediction system manually on certain <code>Part</code>s? Or another example, what if you want to get a list of all currently predicted <code>Instance</code>s?</p> <p>Fortunately, in the Server Authority system, there exists new services and <code>Instance</code>s allowing you to control the system much greater than ever before.</p>"},{"location":"main/aurora/#auroraservice","title":"AuroraService","text":"<p>This is the first new main service in Server Authority, where you're able to manually configure the prediction and physics. Its methods and events are listed below.</p>"},{"location":"main/aurora/#methods","title":"Methods","text":""},{"location":"main/aurora/#auroraservicestartpredictiontarget-instance","title":"<code>AuroraService:StartPrediction(target: Instance): ()</code>","text":"<p>This method allows you to start prediction manually on the target <code>Instance</code>. When it is used, the engine will start predicting the physics of the said <code>Instance</code>.</p>"},{"location":"main/aurora/#auroraservicestoppredictiontarget-instance","title":"<code>AuroraService:StopPrediction(target: Instance): ()</code>","text":"<p>This method stops the prediction on the target <code>Instance</code>. This method also allows you to restore the network ownership behavior of the previous system.</p>"},{"location":"main/aurora/#auroraservicegetpredictedinstances-instance","title":"<code>AuroraService:GetPredictedInstances(): {Instance}</code>","text":"<p>This method returns a table which contains the current predicted <code>Instance</code>s by the Server Authority system.</p>"},{"location":"main/aurora/#auroraserviceispredictedtarget-instance-boolean","title":"<code>AuroraService:IsPredicted(target: Instance): boolean</code>","text":"<p>This method returns a <code>boolean</code>, indicating if the provided <code>Instance</code> is being predicted by the engine or not.</p>"},{"location":"main/aurora/#auroraservicegetserverviewtarget-instance-instance","title":"<code>AuroraService:GetServerView(target: Instance): Instance</code>","text":"<p>This method will return a completely new <code>Instance</code> that most likely shows how the server views the target <code>Instance</code>.  Parenting it to a container such as <code>Workspace</code> will show the exact same properties of the target <code>Instance</code>.</p>"},{"location":"main/aurora/#auroraserviceupdatepropertiestarget-instance","title":"<code>AuroraService:UpdateProperties(target: Instance): ()</code>","text":"<p>This method most likely is used to manually update an <code>Instance</code>'s properties, while its being predicted.</p>"},{"location":"main/aurora/#auroraserviceshowdebugvisaulizerstate-boolean","title":"<code>AuroraService:ShowDebugVisaulizer(state: boolean): ()</code>","text":"<p>This method, when called on the server in a play-test, shows you information about the current state of the prediction system. It contains many elements such as the prediction success rate on both <code>Instance</code>s and scripts. Or how many predicted <code>Instance</code>s there are, live.</p>"},{"location":"main/aurora/#auroraservicegetworldstepid-number","title":"<code>AuroraService:GetWorldStepId(): number</code>","text":"<p>This method returns the current world step id, which is a number. Step id is presumably used for rolling back to a previous state of the prediction.</p>"},{"location":"main/aurora/#auroraservicegetremoteworldstepid-number","title":"<code>AuroraService:GetRemoteWorldStepId(): number</code>","text":"<p>There's not much information about this method, other than it always returns 0.</p>"},{"location":"main/aurora/#auroraservicestepphysicsworldsteps-number-instances-instance","title":"<code>AuroraService:StepPhysics(worldsteps: number, instances: {Instance}): ()</code>","text":"<p>This method steps the physics of the given <code>Instance</code>s by the given <code>worldsteps</code> amount.  All the given <code>Instance</code>s must be a <code>BasePart</code>. If an <code>Instance</code> is not a <code>BasePart</code> in this table, then it will be ignored for the physics step. </p>"},{"location":"main/aurora/#auroraservicesetincomingreplicationlagseconds-number","title":"<code>AuroraService:SetIncomingReplicationLag(seconds: number): ()</code>","text":"<p>This method allows you to set the incoming replication lag. It may be used while debugging.</p>"},{"location":"main/aurora/#input-recording","title":"Input Recording","text":"<p>Currently unsure of what input recording does, as all of the methods described below seemingly do nothing. Will update when more information has been found.</p>"},{"location":"main/aurora/#auroraservicestartinputrecording","title":"<code>AuroraService:StartInputRecording(): ()</code>","text":"<p>This method allows you to start recording input.</p>"},{"location":"main/aurora/#auroraservicestopinputrecording","title":"<code>AuroraService:StopInputRecording(): ()</code>","text":"<p>This method allows you to stop recording input.</p>"},{"location":"main/aurora/#auroraserviceplayinputrecording","title":"<code>AuroraService:PlayInputRecording(): ()</code>","text":"<p>This method allows you to play the recorded input.</p>"},{"location":"main/aurora/#auroraservicesetpropertyisinputtarget-instance-propertyname-string-isinput-bool","title":"<code>AuroraService:SetPropertyIsInput(target: Instance, propertyName: string, isInput: bool): ()</code>","text":"<p>This method presumably allows you to set <code>isInput</code> to a property of a target <code>Instance</code>.</p>"},{"location":"main/aurora/#events","title":"Events","text":"<p>Warning</p> <p>Attempting to connect to these events outside of a Behavior <code>AuroraScript</code> will error.</p>"},{"location":"main/aurora/#auroraservicestep","title":"<code>AuroraService.Step</code>","text":"<p>This event is fired when <code>AuroraService:StepPhysics()</code> has been called.</p>"},{"location":"main/aurora/#auroraservicefixedratetickdeltatime-number-worldstepid-number","title":"<code>AuroraService.FixedRateTick(deltaTime: number, worldStepId: number)</code>","text":"<p>This event is the same as <code>RunService.FixedHeartbeat</code>, but provides an additional parameter called <code>worldStepId</code>.</p>"},{"location":"main/aurora/#auroraservicemispredictionworldstepid-number-mispredictedinstances-instance","title":"<code>AuroraService.Misprediction(worldStepId: number, mispredictedInstances: {Instance})</code>","text":"<p>This event is the same as <code>RunService.Misprediction</code>, and is fired when a misprediction occurs on certain <code>Instance</code>(s). This happens when there's a mismatch between the client and the server's position on an <code>Instance</code>'s physics and movement.</p>"},{"location":"main/aurora/#auroraservicerollbackworldstepid-number","title":"<code>AuroraService.Rollback(worldStepId: number)</code>","text":"<p>This event is fired when a rollback occurs. Rollbacks generally occur after a misprediction, which causes an <code>Instance</code> to be reverted back to its previous state.</p> <p>Info</p> <p>These are all of the current events and the methods of AuroraService. If more information gets found about them, this documentation will be updated.</p>"},{"location":"main/aurora/#aurorascript","title":"AuroraScript","text":"<p>Info</p> <p>It is most likely that Roblox will be changing the name \"AuroraScript\" to \"BehaviorScript\" in the near future, to more accurately represent what it does.</p> <p>This is a new unique <code>Script</code> object that allows you to connect to the various events of <code>AuroraService</code>, and define Behaviors that operate on them. </p> <p>Unlike the other <code>Script</code> types, <code>AuroraScript</code> is pretty limited in terms of what is possible to do with it. This is due to its purpose mainly being related to server authority and prediction, and not the main game logic. Here are the limitions that I'm currently aware of:</p> <ul> <li>All <code>AuroraScript</code>s in the same location (e.g, <code>workspace</code>) must have a different name. Otherwise, one of them will not run.</li> <li>Certain APIs and global libraries do not work in the environment of an <code>AuroraScript</code>. The ones I'm aware of at the moment are:<ul> <li>All methods of the <code>task</code> library (Except for <code>task.cancel()</code>).</li> <li><code>RunService:IsClient()</code> and <code>RunService:IsServer()</code>.</li> <li><code>coroutine.yield()</code> (Behaviors cannot yield.)</li> </ul> </li> </ul> <p>Besides the limitations, generally <code>AuroraScript</code>s should always be parented to a location that can be both accessed from the client and the server, such as <code>ReplicatedStorage</code>. If you parent an <code>AuroraScript</code> to a location such as <code>ServerScriptStorage</code>, this will cause it to only run on the server, and not the client. This defeats the whole purpose of <code>AuroraScript</code>s, as they run both on the server and the client simultaneously.</p>"},{"location":"main/aurora/#methods_1","title":"Methods","text":""},{"location":"main/aurora/#aurorascriptaddtoinstance-instance","title":"<code>AuroraScript:AddTo(instance: Instance): ()</code>","text":"<p>This method binds the Behavior <code>AuroraScript</code> to the specified <code>Instance</code>. This then calls the (if defined) <code>.OnStart</code> method of the Behavior.</p> <p>Behaviors can also be bound manually, without the need of this method. With the Server Authority feature enabled, the Properties widget gain a new section for every <code>Instance</code>, called: \"Behaviors\". Clicking the \"+\" button on this section will allow you to find and bind any Behavior on an <code>Instance</code>.</p>"},{"location":"main/aurora/#aurorascriptremovefrominstance-instance","title":"<code>AuroraScript:RemoveFrom(instance: Instance): ()</code>","text":"<p>This method removes the Behavior <code>AuroraScript</code> from the specified <code>Instance</code>.</p>"},{"location":"main/aurora/#aurorascriptisoninstanceinstance-instance","title":"<code>AuroraScript:IsOnInstance(instance: Instance): ()</code>","text":"<p>This method allows you to check if the Behavior <code>AuroraScript</code> is on the specified <code>Instance</code>.</p>"},{"location":"main/aurora/#aurorascriptsignalfiredinstance-instance-topic-string-rbxscriptsignal","title":"<code>AuroraScript:SignalFired(instance: Instance, topic: string): RBXScriptSignal</code>","text":"<p>This method allows you to create a Signal that is fired when the <code>AuroraScriptObject</code> of the <code>AuroraScript</code> publishes a value with a topic.</p>"},{"location":"main/aurora/#behavior","title":"Behavior","text":"<p>Every <code>AuroraScript</code> comes with a global data type called <code>Behavior</code>, which can be accessed everywhere from the script. This Behavior allows you to connect to certain methods and events that allow you to (presumably) configure how the prediction on a certain <code>Instance</code> works.</p> <p>Info</p> <p>The term \"Behavior\" actually represents an <code>AuroraScript</code>. <code>AuroraScript</code>s do not have Behaviors, they are the Behaviors themselves. In certain places, for example the \"Behaviors\" section in the Properties window, this is more apparent.</p> <p>Warning</p> <p>Every Behavior must be bound to an <code>Instance</code> for them to work.</p> <p>There are certain methods you have to define in the Behavior for it to start working. They are listed below.</p>"},{"location":"main/aurora/#behavioronstartself-aurorascriptobject","title":"<code>Behavior.OnStart(self: AuroraScriptObject): ()</code>","text":"<p>This is a special method that you can define in the Behavior, which runs when the Behavior has been started. It allows you to connect to various events of the <code>AuroraService</code>, and do some other things.</p> <pre><code>function Behavior.OnStart(self: AuroraScriptObject)\n    print(self)\nend\n</code></pre> <p>You might've noticed that <code>.OnStart</code> has a parameter called <code>self</code>, which is an <code>AuroraScriptObject</code>. This is the object that is given to every function that you define in the Behavior. It will be explained in detail in the next section.</p> <p>Info</p> <p>Behaviors are started when the physics simulation begins, if they've already been bound to an <code>Instance</code> before the simulation. If not, then Behaviors are started after <code>:AddTo()</code> has been called on them, or if they've been manually bound to an <code>Instance</code> in the Properties widget.</p>"},{"location":"main/aurora/#behavioronstopself-aurorascriptobject","title":"<code>Behavior.OnStop(self: AuroraScriptObject): ()</code>","text":"<p>This is a special method that you can define in the Behavior, which runs when the Behavior has been stopped.</p> <pre><code>function Behavior.OnStop(self: AuroraScriptObject)\n    print(self)\nend\n</code></pre> <p>Info</p> <p>Behaviors are stopped when the Physics simulation ends, if they've already been started. If not, then Behaviors are stopped when <code>:RemoveFrom()</code> has been called on them, or if they've been manually removed from an <code>Instance</code> in the Properties widget.</p>"},{"location":"main/aurora/#behaviordeclarefieldfieldname-string-_-type-boolean-cframe-color3-enum-instance-number-random-vector2-vector3","title":"<code>Behavior.DeclareField(fieldName: string, _: { Type: \"boolean\" | \"cframe\" | \"color3\" | \"enum\" | \"instance\" | \"number\" | \"random\" | \"vector2\" | \"vector3\" }): ()</code>","text":"<p>This method allows you to define a field with a certain type in the <code>AuroraScriptObject</code>. The defined field will appear as a property within the <code>AuroraScriptObject</code>.</p>"},{"location":"main/aurora/#aurorascriptobject","title":"AuroraScriptObject","text":"<p>This is the object given to the every function defined in the Behavior. It has certain properties and methods that allows you to do things such as manual prediction, sending messages across Behaviors, and more. </p> <pre><code>type AuroraScriptObject = {\n    Instance: Instance,\n    Frame: number,\n    LODLevel: number,\n    Connect: (self: AuroraScriptObject, signal: RBXScriptSignal, functionName: string) -&gt; RBXScriptConnection,\n    Subscribe: (self: AuroraScriptObject, topic: string, functionName: string) -&gt; string,\n    Publish: (self: AuroraScriptObject, topic: string, ...any) -&gt; any,\n    SendMessage: (self: AuroraScriptObject, boundInstance: Instance, behaviorName: string, functionName: string, ...any) -&gt; ...any,\n    Delay: (self: AuroraScriptObject, amount: number, functionName: string) -&gt; string,\n    SetMaxFrequency: (self: AuroraScriptObject, frequency: number) -&gt; number\n}\n\nfunction Behavior.OnStart(self: AuroraScriptObject)\n    print(self) -- prints the AuroraScriptObject\nend\n</code></pre> <p>Now be warned, unlike any other object which is found in the Roblox API, <code>AuroraScriptObject</code> does not reflect the properties found in the API dump. Even when you print this object, it does not give you any property names that allows you to directly access a certain value.</p> <p>An example:</p> <pre><code>{\n    [Attached Instance] = Part,\n    [Behavior] = AuroraScript,\n    [Frame ID] = 509,\n    [self] =  \u25b6 {...}\n}\n</code></pre> <p>This is a detailed string that shows you information about the <code>AuroraScriptObject</code>, such as which frame it currently is on, the Behavior it is from, the bound instance, and lastly, the <code>self</code> table, which is used to show you the declared fields made with <code>Behavior.DeclareField()</code> function. (These field properties can be accessed through indexing the <code>AuroraScriptObject</code> with their name.)</p> <p>Unfortunately, you cannot access these properties directly, and most likely this information is only shown for debugging purposes. In the previous example however, you might have noticed that I've added an <code>AuroraScriptObject</code> type which contains information about all of the currently known and actually accessible methods and properties of the <code>AuroraScriptObject</code>.  (Of course, I have found these properties using reverse-engineering methods.) They are described in detail below.</p>"},{"location":"main/aurora/#properties","title":"Properties","text":""},{"location":"main/aurora/#aurorascriptobjectinstance","title":"<code>AuroraScriptObject.Instance</code>","text":"<p>This is the <code>Instance</code> that the Behavior is bound to.</p>"},{"location":"main/aurora/#aurorascriptobjectframe","title":"<code>AuroraScriptObject.Frame</code>","text":"<p>The current Frame the world is on. Most likely changes after Heartbeat or PreAnimation.</p>"},{"location":"main/aurora/#aurorascriptobjectlodlevel","title":"<code>AuroraScriptObject.LODLevel</code>","text":"<p>The level of distance number of the Behavior. Not sure what it is supposed to be used for at the moment.</p>"},{"location":"main/aurora/#methods_2","title":"Methods","text":""},{"location":"main/aurora/#aurorascriptobjectconnectself-aurorascriptobject-signal-rbxscriptsignal-functionname-string-rbxscriptconnection","title":"<code>AuroraScriptObject.Connect:(self: AuroraScriptObject, signal: RBXScriptSignal, functionName: string) -&gt; RBXScriptConnection</code>","text":"<p>This method allows you to connect to a certain given <code>RBXScriptSignal</code>. It is mostly used to connecting to certain <code>AuroraService</code> events. The <code>functionName</code> argument must be the name of a function in the Behavior.</p> <pre><code>type AuroraScriptObject = {\n    Instance: Instance,\n    Frame: number,\n    LODLevel: number,\n    Connect: (self: AuroraScriptObject, signal: RBXScriptSignal, functionName: string) -&gt; RBXScriptConnection,\n    Subscribe: (self: AuroraScriptObject, topic: string, functionName: string) -&gt; string,\n    Publish: (self: AuroraScriptObject, topic: string, ...any) -&gt; any,\n    SendMessage: (self: AuroraScriptObject, boundInstance: Instance, behaviorName: string, functionName: string, ...any) -&gt; ...any,\n    Delay: (self: AuroraScriptObject, amount: number, functionName: string) -&gt; string,\n    SetMaxFrequency: (self: AuroraScriptObject, frequency: number) -&gt; number\n}\n\nfunction Behavior.OnStart(self: AuroraScriptObject)\n    self:Connect(AuroraService.FixedRateTick, \"Predict\")\nend\n\nfunction Behavior.Predict(self: AuroraScriptObject, deltaTime: number, worldStepId: number) -- This method will get called whenever the .FixedRateTick event fires.\n    print(self, deltaTime, worldStepId)\nend\n</code></pre> <p>Warning</p> <p><code>.Connect</code> can only be called in the <code>.OnStart</code> function. Attempting to call this function anywhere else will cause an error.</p>"},{"location":"main/aurora/#aurorascriptobjectsubscribeself-aurorascriptobject-topic-string-functionname-string-string","title":"<code>AuroraScriptObject.Subscribe(self: AuroraScriptObject, topic: string, functionName: string) -&gt; string</code>","text":"<p>This method allows you to subcribe to a published value in the Behavior with a certain <code>topic</code>. The <code>functionName</code> must be the name of a function in the Behavior.</p> <p>The subcribed function will always have 2 arguments by default, the self <code>AuroraScriptObject</code> and the bound <code>Instance</code>. Additional arguments will come after. Calling this method will return the value of the <code>topic</code> parameter.</p> <p>Warning</p> <p>This function can only be called in <code>.OnStart</code>.</p>"},{"location":"main/aurora/#aurorascriptobjectpublishself-aurorascriptobject-topic-string-any-any","title":"<code>AuroraScriptObject.Publish(self: AuroraScriptObject, topic: string, ...any) -&gt; any</code>","text":"<p>This method allows you to publish a value in the Behavior with a certain <code>topic</code>. The last argument given to this method will be returned as a value.</p> <p>Warning</p> <p>This function cannot be called in <code>.OnStart</code>.</p> <pre><code>type AuroraScriptObject = {\n    Instance: Instance,\n    Frame: number,\n    LODLevel: number,\n    Connect: (self: AuroraScriptObject, signal: RBXScriptSignal, functionName: string) -&gt; RBXScriptConnection,\n    Subscribe: (self: AuroraScriptObject, topic: string, functionName: string) -&gt; string,\n    Publish: (self: AuroraScriptObject, topic: string, ...any) -&gt; any,\n    SendMessage: (self: AuroraScriptObject, boundInstance: Instance, behaviorName: string, functionName: string, ...any) -&gt; ...any,\n    Delay: (self: AuroraScriptObject, amount: number, functionName: string) -&gt; string,\n    SetMaxFrequency: (self: AuroraScriptObject, frequency: number) -&gt; number\n}\n\nfunction Behavior.OnStart(self: AuroraScriptObject)\n    self:Subscribe(\"Test\", \"GetPublishedValue\")\n    self:Connect(AuroraService.FixedRateTick, \"OnFixedRateTick\")\nend\n\nfunction Behavior.OnFixedRateTick(self: AuroraScriptObject, deltaTime: number, worldStepId: number)\n    self:Publish(\"Test\", \"Hello!\")\nend\n\nfunction Behavior.GetPublishedValue(self: AuroraScriptObject, boundInstance: Instance, recievedValue: any)\n    print(boundInstance, recievedValue) -- Instance, Hello!\nend\n</code></pre>"},{"location":"main/aurora/#aurorascriptobjectsendmessageself-aurorascriptobject-boundinstance-instance-behaviorname-string-functionname-string-any-any","title":"<code>AuroraScriptObject.SendMessage(self: AuroraScriptObject, boundInstance: Instance, behaviorName: string, functionName: string, ...any) -&gt; ...any</code>","text":"<p>This method allows you to communicate with other Behaviors in a world. When sending a message, you must specify the <code>Instance</code> that a Behavior is bound to, the name of the Behavior, and the name of the function you want to send this message to. Then, you can add additional values as arguments to send to the function.</p>"},{"location":"main/aurora/#sending-and-recieving-messages","title":"Sending and Recieving Messages","text":"<p>Let's assume we have 2 <code>AuroraScript</code>s in the <code>workspace</code> called: \"Test_1\", and \"Test_2\". And let's also assume we have 2 <code>Part</code>s these Behavior <code>AuroraScript</code>s are bound to.</p> <p>Our system would be like this:</p> <p>Test_1 --&gt; Part Test_2 --&gt; Part_2</p> <p>If we wanted to send a message from Test_1 to Test_2, how would we do it? This is where <code>:SendMessage()</code> comes in. Using this method, we can send and recieve messages across different Behaviors.</p>"},{"location":"main/aurora/#test_1","title":"Test_1:","text":"<pre><code>local AuroraService = game:GetService(\"AuroraService\")\n\ntype AuroraScriptObject = {\n    Instance: Instance,\n    Frame: number,\n    LODLevel: number,\n    Connect: (self: AuroraScriptObject, signal: RBXScriptSignal, functionName: string) -&gt; RBXScriptConnection,\n    Subscribe: (self: AuroraScriptObject, topic: string, functionName: string) -&gt; string,\n    Publish: (self: AuroraScriptObject, topic: string, ...any) -&gt; any,\n    SendMessage: (self: AuroraScriptObject, boundInstance: Instance, behaviorName: string, functionName: string, ...any) -&gt; ...any,\n    Delay: (self: AuroraScriptObject, amount: number, functionName: string) -&gt; string,\n    SetMaxFrequency: (self: AuroraScriptObject, frequency: number) -&gt; number\n}\n\nfunction Behavior.OnStart(self: AuroraScriptObject)\n    self:Connect(AuroraService.FixedRateTick, \"OnFixedRateTick\")\nend\n\nfunction Behavior.OnFixedRateTick(self: AuroraScriptObject, deltaTime: number, worldStepId: number)\n    self:SendMessage(game.Workspace.Part_2, \"Test_2\", \"Test\", \"Hello!\")\nend\n</code></pre>"},{"location":"main/aurora/#test_2","title":"Test_2","text":"<pre><code>local AuroraService = game:GetService(\"AuroraService\")\n\ntype AuroraScriptObject = {\n    Instance: Instance,\n    Frame: number,\n    LODLevel: number,\n    Connect: (self: AuroraScriptObject, signal: RBXScriptSignal, functionName: string) -&gt; RBXScriptConnection,\n    Subscribe: (self: AuroraScriptObject, topic: string, functionName: string) -&gt; string,\n    Publish: (self: AuroraScriptObject, topic: string, ...any) -&gt; any,\n    SendMessage: (self: AuroraScriptObject, boundInstance: Instance, behaviorName: string, functionName: string, ...any) -&gt; ...any,\n    Delay: (self: AuroraScriptObject, amount: number, functionName: string) -&gt; string,\n    SetMaxFrequency: (self: AuroraScriptObject, frequency: number) -&gt; number\n}\n\nfunction Behavior.OnStart(self: AuroraScriptObject)\n    self:Connect(AuroraService.FixedRateTick, \"OnFixedRateTick\")\nend\n\nfunction Behavior.OnFixedRateTick(self: AuroraScriptObject, deltaTime: number, worldStepId: number) end\n\nfunction Behavior.OnMessageTest(self: AuroraScriptObject, recievedMessage: string)\n    warn(recievedMessage) -- \"Hello!\"\nend\n</code></pre> <p>Warning</p> <p>All functions recieving a message must have a name that starts with \"OnMessage\". For example, if we call the <code>:SendMessage()</code> with a <code>functionName</code> argument called \"Test\", then the function name must be \"OnMessageTest\" on the recieving Behavior.</p>"},{"location":"main/aurora/#aurorascriptobjectdelayself-aurorascriptobject-amount-number-functionname-string-string","title":"<code>AuroraScriptObject.Delay(self: AuroraScriptObject, amount: number, functionName: string): string</code>","text":"<p>This method allows you to run a function in the Behavior with a certain amount of delay. (In seconds)</p>"},{"location":"main/aurora/#aurorascriptobjectsetmaxfrequencyself-aurorascriptobject-frequency-number-number","title":"<code>AuroraScriptObject.SetMaxFrequency(self: AuroraScriptObject, frequency: number): number</code>","text":"<p>This method allows you to set the maximum amount of frequency the <code>AuroraScriptObject</code> can run with. Must be a value between 1 to 60.</p>"},{"location":"main/aurora/#aurorascriptservice","title":"AuroraScriptService","text":"<p>This service is meant to manage and communicate with Behavior <code>AuroraScript</code>s. Unlike AuroraService however, it does not have special properties or events, just methods.</p>"},{"location":"main/aurora/#methods_3","title":"Methods","text":""},{"location":"main/aurora/#aurorascriptservicesendmessageinstance-instance-behaviorname-string-functionname-string-any","title":"<code>AuroraScriptService:SendMessage(instance: Instance, behaviorName: string, functionName: string, ...: any): ()</code>","text":"<p>This method works exactly the same as the <code>AuroraScriptObject:SendMessage()</code>, except it is used outside of Behaviors to send messages to Behaviors. The same rules apply.</p>"},{"location":"main/aurora/#aurorascriptservicegetbehaviors-aurorascript","title":"<code>AuroraScriptService:getBehaviors(): {AuroraScript}</code>","text":"<p>This method returns a table containing all of the Behaviors in the place.</p>"},{"location":"main/aurora/#aurorascriptservicegetbehaviorsforinstanceinstance-instance-aurorascript","title":"<code>AuroraScriptService:getBehaviorsForInstance(instance: Instance): {AuroraScript}</code>","text":"<p>This method returns a table containing all of the Behaviors bound to the specified <code>Instance</code>.</p>"},{"location":"main/aurora/#aurorascriptservicegetinstancesforbehaviorbehavior-aurorascript-instance","title":"<code>AuroraScriptService:getInstancesForBehavior(behavior: AuroraScript): {Instance}</code>","text":"<p>This method returns a table containing all of the <code>Instance</code>s that the specified Behavior is bound to.</p>"},{"location":"main/aurora/#aurorascriptservicefindbindingsinstance-instance-string-any","title":"<code>AuroraScriptService:FindBindings(instance: Instance): { [string]: any }</code>","text":"<p>This method returns a table containing all of the <code>AuroraScriptObject</code>s from the Behaviors bound to an <code>Instance</code>. Can only be used within <code>AuroraScript</code>s.</p>"},{"location":"main/aurora/#aurorascriptservicefindbindinginstance-instance-scriptname-string-aurorascriptobject","title":"<code>AuroraScriptService:FindBinding(instance: Instance, scriptName: string): AuroraScriptObject</code>","text":"<p>This method returns the <code>AuroraScriptObject</code> from the target Behavior (with the <code>scriptName</code>) bound to an <code>Instance</code>. Can only be used within <code>AuroraScript</code>s.</p>"},{"location":"main/aurora/#aurorascriptservicegetlocalframeid-number","title":"<code>AuroraScriptService:GetLocalFrameId(): number</code>","text":"<p>This method returns a number that presumably indicates the current frame of the world.</p>"},{"location":"main/credits/","title":"Closing Thoughts","text":"<p>That's all! Hopefully I could explain these new features well. If you have any questions or things to share, please contact me through my Twitter or DevForum. I may update this documentation with more information whenever I find them. Cheers!</p>"},{"location":"main/credits/#credits","title":"Credits","text":""},{"location":"main/credits/#noctua-tenebrisnoctua-on-twitter","title":"Noctua (@TenebrisNoctua on Twitter)","text":""},{"location":"main/credits/#max-maximumadhd-on-twitter","title":"Max (@MaximumADHD on Twitter)","text":""},{"location":"main/credits/#aztup-realaztup-on-twitter","title":"Aztup (@RealAztup on Twitter)","text":""},{"location":"main/credits/#x64-walletoverflow-on-devforum","title":"x64 (@WalletOverflow on DevForum)","text":""},{"location":"main/credits/#welblander-welblander-on-devforum","title":"welblander (@welblander on DevForum)","text":""}]}